# 第8章：错误和异常处理

## 目录
- [8.1 错误和异常概述](#81-错误和异常概述)
- [8.2 常见的内置异常类型](#82-常见的内置异常类型)
- [8.3 异常处理：try-except语句](#83-异常处理try-except语句)
- [8.4 多个except子句和异常组](#84-多个except子句和异常组)
- [8.5 else和finally子句](#85-else和finally子句)
- [8.6 自定义异常](#86-自定义异常)
- [8.7 异常链与上下文](#87-异常链与上下文)
- [8.8 异常处理的最佳实践](#88-异常处理的最佳实践)
- [8.9 综合示例](#89-综合示例)
- [8.10 本章练习](#810-本章练习)

---

## 8.1 错误和异常概述

### 什么是错误和异常？
在Python中，错误主要分为两类：
1. **语法错误（Syntax Error）**：代码不符合Python语法规则
2. **异常（Exception）**：程序运行时发生的错误

```python
# 语法错误示例
print("Hello World"  # 缺少右括号，会在解析时报错

# 运行时异常示例
result = 10 / 0  # ZeroDivisionError，语法正确但运行时出错
```

### OOP中的异常处理优势
面向对象编程使得异常处理更加模块化和可维护：

```python
# 面向过程的错误处理
def process_data_old(data):
    if data is None:
        return "错误：数据为空"
    if not isinstance(data, dict):
        return "错误：数据类型不正确"
    if 'value' not in data:
        return "错误：缺少必要字段"
    # 实际处理逻辑
    return data['value'] * 2

# 面向对象的异常处理
class DataProcessor:
    def process(self, data):
        if data is None:
            raise ValueError("数据不能为空")
        if not isinstance(data, dict):
            raise TypeError("数据必须是字典类型")
        if 'value' not in data:
            raise KeyError("数据缺少'value'字段")
        # 实际处理逻辑
        return data['value'] * 2

# 使用
processor = DataProcessor()
try:
    result = processor.process({"value": 10})
    print(f"结果: {result}")
except (ValueError, TypeError, KeyError) as e:
    print(f"处理失败: {e}")
```

### 异常处理的重要性
1. **提高程序健壮性**：避免程序因意外错误而崩溃
2. **改善用户体验**：提供清晰的错误信息和恢复选项
3. **便于调试**：明确错误发生的位置和原因
4. **资源管理**：确保资源被正确释放

---

## 8.2 常见的内置异常类型

### 异常层次结构
Python的异常类形成了清晰的层次结构：

```python
# 查看异常层次
def print_exception_hierarchy():
    """打印异常类层次结构"""
    import inspect
    
    def print_tree(cls, indent=0):
        print("  " * indent + cls.__name__)
        for subclass in cls.__subclasses__():
            print_tree(subclass, indent + 1)
    
    print("异常类层次结构:")
    print_tree(BaseException)

# print_exception_hierarchy()
```

### 常见异常示例
```python
class ExceptionDemo:
    """演示常见异常类型"""
    
    @staticmethod
    def demonstrate_zero_division():
        """除零错误"""
        try:
            result = 10 / 0
        except ZeroDivisionError as e:
            return f"ZeroDivisionError: {e}"
    
    @staticmethod
    def demonstrate_type_error():
        """类型错误"""
        try:
            result = "10" + 5
        except TypeError as e:
            return f"TypeError: {e}"
    
    @staticmethod
    def demonstrate_value_error():
        """值错误"""
        try:
            number = int("abc")
        except ValueError as e:
            return f"ValueError: {e}"
    
    @staticmethod
    def demonstrate_index_error():
        """索引错误"""
        try:
            my_list = [1, 2, 3]
            print(my_list[5])
        except IndexError as e:
            return f"IndexError: {e}"
    
    @staticmethod
    def demonstrate_key_error():
        """键错误"""
        try:
            my_dict = {"name": "Alice", "age": 25}
            print(my_dict["address"])
        except KeyError as e:
            return f"KeyError: {e}"
    
    @staticmethod
    def demonstrate_file_not_found():
        """文件未找到"""
        try:
            with open("nonexistent.txt", "r") as f:
                content = f.read()
        except FileNotFoundError as e:
            return f"FileNotFoundError: {e}"
    
    @staticmethod
    def demonstrate_attribute_error():
        """属性错误"""
        try:
            my_string = "Hello"
            my_string.append(" World")
        except AttributeError as e:
            return f"AttributeError: {e}"

# 演示所有异常
demo = ExceptionDemo()
methods = [m for m in dir(demo) if m.startswith('demonstrate')]
for method in methods:
    result = getattr(demo, method)()
    print(result)
```

### 异常类的属性和方法
```python
class ExceptionProperties:
    """演示异常类的属性"""
    
    @staticmethod
    def show_exception_info():
        try:
            # 触发一个异常
            x = 1 / 0
        except ZeroDivisionError as e:
            print(f"异常类型: {type(e)}")
            print(f"异常类名: {e.__class__.__name__}")
            print(f"异常信息: {e}")
            print(f"异常参数: {e.args}")
            print(f"异常文档: {e.__doc__}")
            print(f"字符串表示: {str(e)}")
            print(f"repr表示: {repr(e)}")
            
            # 异常的__dict__属性
            print(f"异常字典: {e.__dict__}")
            
            # 添加自定义属性
            e.custom_field = "自定义信息"
            print(f"自定义属性: {e.custom_field}")

# ExceptionProperties.show_exception_info()
```

---

## 8.3 异常处理：try-except语句

### 基本语法
```python
try:
    # 可能引发异常的代码
    pass
except ExceptionType:
    # 异常处理代码
    pass
```

### 基础用法示例
```python
class Calculator:
    """计算器类 - 演示基础异常处理"""
    
    def divide(self, a, b):
        """除法运算"""
        try:
            result = a / b
            return result
        except ZeroDivisionError:
            return "错误：除数不能为零"
        except TypeError:
            return "错误：操作数类型不正确"
    
    def square_root(self, number):
        """平方根计算"""
        try:
            if number < 0:
                raise ValueError("负数没有实数平方根")
            return number ** 0.5
        except ValueError as e:
            return f"错误：{e}"
    
    def process_input(self):
        """处理用户输入"""
        try:
            num = float(input("请输入一个数字: "))
            result = self.square_root(num)
            print(f"平方根: {result}")
        except ValueError as e:
            print(f"输入错误: {e}")
        except KeyboardInterrupt:
            print("\n用户中断操作")
        except Exception as e:
            print(f"未知错误: {type(e).__name__}: {e}")

# 使用示例
calc = Calculator()
print(calc.divide(10, 2))    # 5.0
print(calc.divide(10, 0))    # 错误：除数不能为零
print(calc.divide("10", 2))  # 错误：操作数类型不正确

# calc.process_input()
```

### 使用as关键字获取异常对象
```python
class FileHandler:
    """文件处理器 - 演示详细异常信息"""
    
    def read_file(self, filename):
        """读取文件"""
        try:
            with open(filename, 'r', encoding='utf-8') as file:
                content = file.read()
                print(f"文件内容: {content[:50]}...")  # 只显示前50个字符
                return content
                
        except FileNotFoundError as e:
            print(f"文件未找到错误:")
            print(f"  文件名: {filename}")
            print(f"  错误信息: {e}")
            print(f"  错误号: {e.errno if hasattr(e, 'errno') else 'N/A'}")
            
        except PermissionError as e:
            print(f"权限错误:")
            print(f"  文件名: {filename}")
            print(f"  错误信息: {e}")
            
        except UnicodeDecodeError as e:
            print(f"编码错误:")
            print(f"  文件名: {filename}")
            print(f"  错误位置: {e.start}-{e.end}")
            print(f"  原因: {e.reason}")
            
        except OSError as e:
            print(f"操作系统错误:")
            print(f"  错误码: {e.errno}")
            print(f"  错误信息: {e.strerror}")
            
        except Exception as e:
            print(f"未知错误: {type(e).__name__}: {e}")
            # 记录到日志
            import traceback
            traceback.print_exc()
            
        return None

# 使用示例
handler = FileHandler()
handler.read_file("test.txt")
```

---

## 8.4 多个except子句和异常组

### 多个except子句
```python
class InputValidator:
    """输入验证器 - 演示多个except子句"""
    
    def validate_and_calculate(self):
        """验证输入并计算"""
        while True:
            try:
                # 获取用户输入
                num1 = float(input("请输入第一个数字: "))
                num2 = float(input("请输入第二个数字: "))
                
                operation = input("请选择操作 (+, -, *, /, ^): ")
                
                # 执行计算
                if operation == '+':
                    result = num1 + num2
                elif operation == '-':
                    result = num1 - num2
                elif operation == '*':
                    result = num1 * num2
                elif operation == '/':
                    result = num1 / num2
                elif operation == '^':
                    result = num1 ** num2
                else:
                    raise ValueError(f"不支持的操作: {operation}")
                
                print(f"{num1} {operation} {num2} = {result}")
                break
                
            except ValueError as e:
                if "could not convert" in str(e):
                    print("错误：请输入有效的数字")
                else:
                    print(f"错误：{e}")
                    
            except ZeroDivisionError:
                print("错误：除数不能为零")
                
            except OverflowError:
                print("错误：计算结果太大")
                
            except KeyboardInterrupt:
                print("\n程序被用户中断")
                break
                
            except Exception as e:
                print(f"发生了未知错误: {type(e).__name__}: {e}")
                # 可以选择重新抛出或记录日志
                raise

# 使用示例
# validator = InputValidator()
# validator.validate_and_calculate()
```

### 在一个except子句中捕获多个异常
```python
class DataProcessor:
    """数据处理器 - 演示捕获多个异常"""
    
    def process_data(self, data):
        """处理数据"""
        try:
            # 模拟各种可能的错误
            if isinstance(data, str):
                if data == "divide":
                    return 10 / 0
                elif data == "index":
                    lst = [1, 2, 3]
                    return lst[10]
                elif data == "key":
                    dct = {"a": 1}
                    return dct["b"]
                else:
                    return int(data)
            else:
                return f"处理结果: {data}"
                
        except (ZeroDivisionError, IndexError, KeyError) as e:
            print(f"捕获到数据访问错误: {type(e).__name__}")
            
            # 根据异常类型采取不同措施
            if isinstance(e, ZeroDivisionError):
                print("处理除零错误: 返回默认值0")
                return 0
            elif isinstance(e, IndexError):
                print("处理索引错误: 返回列表最后一个元素")
                return [1, 2, 3][-1] if [1, 2, 3] else None
            elif isinstance(e, KeyError):
                print("处理键错误: 返回默认值")
                return "default"
                
        except ValueError as e:
            print(f"值错误: {e}")
            raise ValueError(f"无法处理数据: {data}") from e
            
        except Exception as e:
            print(f"其他错误: {type(e).__name__}: {e}")
            raise

# 使用示例
processor = DataProcessor()
test_cases = ["divide", "index", "key", "123", "abc", {"name": "test"}]

for test in test_cases:
    print(f"\n处理: {test}")
    try:
        result = processor.process_data(test)
        print(f"结果: {result}")
    except Exception as e:
        print(f"处理失败: {e}")
```

---

## 8.5 else和finally子句

### else子句
```python
class DataLoader:
    """数据加载器 - 演示else子句"""
    
    def load_from_file(self, filename):
        """从文件加载数据"""
        try:
            print(f"尝试加载文件: {filename}")
            with open(filename, 'r') as file:
                data = file.read()
                
        except FileNotFoundError:
            print(f"文件 {filename} 不存在")
            return None
            
        except PermissionError:
            print(f"没有权限读取文件 {filename}")
            return None
            
        else:
            # 只有在没有异常发生时执行
            print(f"文件加载成功，大小: {len(data)} 字节")
            print("进行数据验证...")
            
            # 验证数据
            if not data.strip():
                print("警告：文件为空")
                
            return data
            
    def calculate_statistics(self, numbers):
        """计算统计信息"""
        try:
            if not numbers:
                raise ValueError("数据列表不能为空")
                
            total = sum(numbers)
            count = len(numbers)
            average = total / count
            
        except (ValueError, ZeroDivisionError) as e:
            print(f"计算错误: {e}")
            return None
            
        else:
            # 只有在没有异常发生时执行
            print(f"计算成功: 总和={total}, 数量={count}, 平均={average:.2f}")
            
            # 返回计算结果
            return {
                "total": total,
                "count": count,
                "average": average,
                "min": min(numbers),
                "max": max(numbers)
            }

# 使用示例
loader = DataLoader()

# 测试文件加载
data = loader.load_from_file("test.txt")
if data:
    print(f"加载的数据: {data[:50]}...")

# 测试统计计算
stats = loader.calculate_statistics([1, 2, 3, 4, 5])
if stats:
    print(f"统计结果: {stats}")

empty_stats = loader.calculate_statistics([])
```

### finally子句
```python
class ResourceManager:
    """资源管理器 - 演示finally子句"""
    
    class DatabaseConnection:
        """模拟数据库连接"""
        def __init__(self, name):
            self.name = name
            self.connected = False
            print(f"创建数据库连接: {name}")
        
        def connect(self):
            self.connected = True
            print(f"连接到数据库: {self.name}")
        
        def disconnect(self):
            if self.connected:
                self.connected = False
                print(f"断开数据库连接: {self.name}")
        
        def execute(self, query):
            if not self.connected:
                raise ConnectionError("数据库未连接")
            print(f"执行查询: {query}")
            return f"查询结果: {query}"
    
    def manage_database_old(self):
        """旧式资源管理（容易出错）"""
        db = None
        try:
            db = self.DatabaseConnection("ProductionDB")
            db.connect()
            result = db.execute("SELECT * FROM users")
            print(result)
            
            # 模拟错误
            raise RuntimeError("模拟运行时错误")
            
        except Exception as e:
            print(f"发生错误: {e}")
            
        finally:
            # 无论是否发生异常都会执行
            if db and db.connected:
                db.disconnect()
            print("资源清理完成")
    
    def manage_database_new(self):
        """新式资源管理（使用with语句）"""
        class DatabaseContext:
            def __init__(self, db_name):
                self.db_name = db_name
                self.db = None
            
            def __enter__(self):
                self.db = ResourceManager.DatabaseConnection(self.db_name)
                self.db.connect()
                return self.db
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                if self.db:
                    self.db.disconnect()
                print(f"上下文管理器退出，异常类型: {exc_type}")
                # 返回False让异常继续传播
                return False
        
        try:
            with DatabaseContext("TestDB") as db:
                result = db.execute("SELECT * FROM products")
                print(result)
                
                # 模拟错误
                value = int("not a number")
                
        except ValueError as e:
            print(f"值错误: {e}")
        except Exception as e:
            print(f"其他错误: {e}")

# 使用示例
manager = ResourceManager()
print("=== 旧式资源管理 ===")
manager.manage_database_old()

print("\n=== 新式资源管理 ===")
manager.manage_database_new()
```

### 完整的try-except-else-finally结构
```python
class CompleteExceptionHandling:
    """完整的异常处理结构演示"""
    
    def process_transaction(self, transaction_data):
        """处理交易"""
        connection = None
        transaction_id = None
        
        try:
            print("开始处理交易...")
            
            # 模拟建立连接
            connection = self._establish_connection()
            
            # 验证数据
            self._validate_transaction_data(transaction_data)
            
            # 执行交易
            transaction_id = self._execute_transaction(connection, transaction_data)
            
        except ValueError as e:
            print(f"数据验证失败: {e}")
            return None
            
        except ConnectionError as e:
            print(f"连接错误: {e}")
            return None
            
        except Exception as e:
            print(f"交易处理失败: {type(e).__name__}: {e}")
            return None
            
        else:
            # 只有在没有异常发生时执行
            print(f"交易执行成功!")
            print(f"交易ID: {transaction_id}")
            print("发送成功通知...")
            
            return transaction_id
            
        finally:
            # 无论是否发生异常都会执行
            print("清理资源...")
            if connection:
                self._close_connection(connection)
            print(f"处理完成，交易状态: {'成功' if transaction_id else '失败'}")
    
    def _establish_connection(self):
        """建立连接"""
        print("建立数据库连接...")
        # 模拟连接
        import random
        if random.random() < 0.1:
            raise ConnectionError("连接超时")
        return "database_connection"
    
    def _validate_transaction_data(self, data):
        """验证交易数据"""
        print("验证交易数据...")
        if not data.get('amount'):
            raise ValueError("交易金额不能为空")
        if data['amount'] <= 0:
            raise ValueError("交易金额必须大于0")
        if not data.get('account'):
            raise ValueError("账户不能为空")
    
    def _execute_transaction(self, connection, data):
        """执行交易"""
        print(f"执行交易: {data}")
        # 模拟交易执行
        import random
        if random.random() < 0.1:
            raise RuntimeError("交易处理失败")
        return f"TX{random.randint(100000, 999999)}"
    
    def _close_connection(self, connection):
        """关闭连接"""
        print(f"关闭连接: {connection}")

# 使用示例
processor = CompleteExceptionHandling()

# 测试多个交易
test_transactions = [
    {"amount": 100, "account": "ACC001"},
    {"amount": -50, "account": "ACC002"},  # 无效金额
    {"amount": 200, "account": ""},        # 无效账户
    {"amount": 300, "account": "ACC003"},
]

for i, transaction in enumerate(test_transactions, 1):
    print(f"\n{'='*40}")
    print(f"处理交易 {i}: {transaction}")
    result = processor.process_transaction(transaction)
    if result:
        print(f"✓ 交易成功: {result}")
    else:
        print(f"✗ 交易失败")
```

---

## 8.6 自定义异常

### 基础自定义异常
```python
# 基础自定义异常类
class ApplicationError(Exception):
    """应用程序错误基类"""
    pass

class ValidationError(ApplicationError):
    """验证错误"""
    def __init__(self, message, field=None):
        self.message = message
        self.field = field
        super().__init__(self.message)
    
    def __str__(self):
        if self.field:
            return f"{self.field}: {self.message}"
        return self.message

class DatabaseError(ApplicationError):
    """数据库错误"""
    def __init__(self, message, query=None):
        self.message = message
        self.query = query
        super().__init__(self.message)
    
    def get_details(self):
        details = {"message": self.message}
        if self.query:
            details["query"] = self.query
        return details
```

### 完整的自定义异常示例
```python
class BankingSystem:
    """银行系统 - 完整的自定义异常示例"""
    
    class BankError(Exception):
        """银行错误基类"""
        def __init__(self, message, error_code):
            self.message = message
            self.error_code = error_code
            super().__init__(f"[{error_code}] {message}")
    
    class AccountError(BankError):
        """账户错误"""
        pass
    
    class InvalidAccountError(AccountError):
        """无效账户错误"""
        def __init__(self, account_number):
            super().__init__(
                f"账户 {account_number} 不存在或无效",
                "ACC001"
            )
            self.account_number = account_number
    
    class InsufficientFundsError(AccountError):
        """余额不足错误"""
        def __init__(self, account_number, balance, amount):
            super().__init__(
                f"账户 {account_number} 余额不足。当前余额: ${balance:.2f}, 需要: ${amount:.2f}",
                "ACC002"
            )
            self.account_number = account_number
            self.balance = balance
            self.amount = amount
    
    class TransactionError(BankError):
        """交易错误"""
        pass
    
    class InvalidAmountError(TransactionError):
        """无效金额错误"""
        def __init__(self, amount):
            super().__init__(
                f"无效的交易金额: ${amount:.2f}。金额必须大于0",
                "TXN001"
            )
            self.amount = amount
    
    class DailyLimitExceededError(TransactionError):
        """日限额超出错误"""
        def __init__(self, account_number, daily_limit, attempted_amount):
            super().__init__(
                f"账户 {account_number} 日交易限额超出。限额: ${daily_limit:.2f}, 尝试: ${attempted_amount:.2f}",
                "TXN002"
            )
            self.account_number = account_number
            self.daily_limit = daily_limit
            self.attempted_amount = attempted_amount
    
    class SecurityError(BankError):
        """安全错误"""
        pass
    
    class InvalidPinError(SecurityError):
        """无效PIN错误"""
        def __init__(self, attempts_remaining):
            super().__init__(
                f"PIN验证失败。剩余尝试次数: {attempts_remaining}",
                "SEC001"
            )
            self.attempts_remaining = attempts_remaining
    
    class AccountLockedError(SecurityError):
        """账户锁定错误"""
        def __init__(self, account_number, unlock_time):
            super().__init__(
                f"账户 {account_number} 已被锁定。解锁时间: {unlock_time}",
                "SEC002"
            )
            self.account_number = account_number
            self.unlock_time = unlock_time
    
    def __init__(self):
        self.accounts = {
            "ACC001": {"balance": 1000.0, "pin": "1234", "daily_total": 0, "locked": False},
            "ACC002": {"balance": 500.0, "pin": "5678", "daily_total": 0, "locked": False}
        }
        self.daily_limit = 1000.0
    
    def validate_account(self, account_number):
        """验证账户"""
        if account_number not in self.accounts:
            raise self.InvalidAccountError(account_number)
        
        account = self.accounts[account_number]
        if account["locked"]:
            raise self.AccountLockedError(account_number, "明天 00:00")
        
        return account
    
    def validate_pin(self, account_number, pin):
        """验证PIN"""
        account = self.validate_account(account_number)
        
        if account["pin"] != pin:
            attempts = 2  # 模拟剩余尝试次数
            raise self.InvalidPinError(attempts)
    
    def validate_amount(self, amount):
        """验证金额"""
        if amount <= 0:
            raise self.InvalidAmountError(amount)
    
    def validate_daily_limit(self, account_number, amount):
        """验证日限额"""
        account = self.accounts[account_number]
        new_total = account["daily_total"] + amount
        
        if new_total > self.daily_limit:
            raise self.DailyLimitExceededError(account_number, self.daily_limit, new_total)
    
    def withdraw(self, account_number, pin, amount):
        """取款"""
        try:
            print(f"\n尝试取款 - 账户: {account_number}, 金额: ${amount:.2f}")
            
            # 验证PIN
            self.validate_pin(account_number, pin)
            
            # 验证金额
            self.validate_amount(amount)
            
            # 验证日限额
            self.validate_daily_limit(account_number, amount)
            
            # 检查余额
            account = self.accounts[account_number]
            if amount > account["balance"]:
                raise self.InsufficientFundsError(account_number, account["balance"], amount)
            
            # 执行取款
            account["balance"] -= amount
            account["daily_total"] += amount
            
            print(f"取款成功! 新余额: ${account['balance']:.2f}")
            return True
            
        except self.BankError as e:
            print(f"取款失败: {e}")
            print(f"错误代码: {e.error_code}")
            return False
            
        except Exception as e:
            print(f"系统错误: {type(e).__name__}: {e}")
            return False

# 使用示例
bank = BankingSystem()

# 测试各种情况
test_cases = [
    ("ACC001", "1234", 200),     # 成功
    ("ACC003", "1234", 200),     # 无效账户
    ("ACC001", "9999", 200),     # 无效PIN
    ("ACC001", "1234", -50),     # 无效金额
    ("ACC001", "1234", 5000),    # 余额不足
    ("ACC001", "1234", 900),     # 日限额超出（假设之前已有交易）
]

for account, pin, amount in test_cases:
    bank.withdraw(account, pin, amount)
    print("-" * 50)
```

---

## 8.7 异常链与上下文

### 异常链（Chained Exceptions）
```python
class DataProcessor:
    """数据处理器 - 演示异常链"""
    
    def process_data(self, data_file):
        """处理数据文件"""
        try:
            # 步骤1: 读取文件
            raw_data = self._read_file(data_file)
            
            # 步骤2: 解析数据
            parsed_data = self._parse_data(raw_data)
            
            # 步骤3: 验证数据
            validated_data = self._validate_data(parsed_data)
            
            # 步骤4: 处理数据
            result = self._process_validated_data(validated_data)
            
            return result
            
        except FileNotFoundError as e:
            # 包装文件错误
            raise self.DataProcessingError(f"无法处理文件: {data_file}") from e
            
        except ValueError as e:
            # 包装解析错误
            raise self.DataProcessingError("数据解析失败") from e
            
        except ValidationError as e:
            # 包装验证错误
            raise self.DataProcessingError("数据验证失败") from e
            
        except Exception as e:
            # 包装其他错误
            raise self.DataProcessingError("数据处理过程中发生未知错误") from e
    
    class DataProcessingError(Exception):
        """数据处理错误"""
        def __init__(self, message, original_error=None):
            super().__init__(message)
            self.original_error = original_error
        
        def __str__(self):
            result = super().__str__()
            if self.original_error:
                result += f"\n原因: {type(self.original_error).__name__}: {self.original_error}"
            return result
    
    def _read_file(self, filename):
        """读取文件"""
        try:
            with open(filename, 'r') as f:
                return f.read()
        except FileNotFoundError as e:
            # 添加更多上下文信息
            e.filename = filename
            raise
    
    def _parse_data(self, raw_data):
        """解析数据"""
        import json
        try:
            return json.loads(raw_data)
        except json.JSONDecodeError as e:
            # 转换异常类型
            raise ValueError(f"JSON解析错误: {e.msg}") from e
    
    def _validate_data(self, data):
        """验证数据"""
        if not isinstance(data, dict):
            raise ValidationError("数据必须是字典")
        if 'value' not in data:
            raise ValidationError("数据缺少'value'字段")
        return data
    
    def _process_validated_data(self, data):
        """处理验证后的数据"""
        return data['value'] * 2

class ValidationError(Exception):
    """验证错误"""
    pass

# 使用示例
processor = DataProcessor()

# 测试异常链
try:
    # 测试文件不存在
    result = processor.process_data("nonexistent.json")
except processor.DataProcessingError as e:
    print(f"捕获到数据处理错误: {e}")
    print(f"原始错误: {e.__cause__}")
    print(f"异常链:")
    import traceback
    traceback.print_exc()
```

### 异常上下文管理
```python
class ContextAwareException(Exception):
    """带上下文的异常"""
    
    def __init__(self, message, context=None):
        super().__init__(message)
        self.context = context or {}
        self.timestamp = __import__('datetime').datetime.now()
    
    def add_context(self, key, value):
        """添加上下文信息"""
        self.context[key] = value
    
    def __str__(self):
        base_str = super().__str__()
        context_str = "\n上下文信息:"
        for key, value in self.context.items():
            context_str += f"\n  {key}: {value}"
        context_str += f"\n时间戳: {self.timestamp}"
        return base_str + context_str

class DatabaseService:
    """数据库服务 - 演示异常上下文"""
    
    def execute_query(self, query, params=None):
        """执行数据库查询"""
        context = {
            "query": query,
            "params": params,
            "service": "DatabaseService",
            "method": "execute_query"
        }
        
        try:
            # 模拟数据库操作
            if "DROP" in query.upper():
                raise RuntimeError("禁止执行DROP语句")
            
            if params and len(params) > 1000:
                raise MemoryError("参数过多")
            
            # 模拟成功
            return {"rows": 1, "data": ["result"]}
            
        except RuntimeError as e:
            # 添加上下文信息
            context["error_type"] = "security_violation"
            raise ContextAwareException(
                "安全策略违规",
                context
            ) from e
            
        except MemoryError as e:
            context["error_type"] = "resource_exhaustion"
            context["param_count"] = len(params) if params else 0
            raise ContextAwareException(
                "资源耗尽",
                context
            ) from e
            
        except Exception as e:
            context["error_type"] = "unknown_error"
            raise ContextAwareException(
                "数据库操作失败",
                context
            ) from e

# 使用示例
db_service = DatabaseService()

try:
    # 测试安全违规
    result = db_service.execute_query("DROP TABLE users;")
except ContextAwareException as e:
    print(f"捕获到带上下文的异常:")
    print(e)
    
    # 添加上下文信息
    e.add_context("user_id", 12345)
    e.add_context("client_ip", "192.168.1.100")
    
    print(f"\n增强的异常信息:")
    print(e)
    
    # 记录到日志
    import logging
    logging.error(f"数据库操作失败: {e}")
```

---

## 8.8 异常处理的最佳实践

### 1. 具体优于宽泛
```python
class BestPractices:
    """异常处理最佳实践"""
    
    @staticmethod
    def specific_over_general():
        """具体异常优于宽泛异常"""
        
        # 不好的做法 ❌
        def bad_practice():
            try:
                # 各种操作
                result = 10 / 0
            except:
                print("发生错误")  # 太宽泛！
        
        # 好的做法 ✅
        def good_practice():
            try:
                result = 10 / 0
            except ZeroDivisionError:
                print("除零错误")
            except ArithmeticError:
                print("算术错误")
            except Exception as e:
                print(f"其他错误: {type(e).__name__}")
                # 记录日志
                import logging
                logging.error(f"未处理的异常: {e}", exc_info=True)
        
        # 实际文件操作示例
        def file_operations(filename):
            try:
                with open(filename, 'r') as f:
                    content = f.read()
                    
            except FileNotFoundError:
                print(f"文件不存在: {filename}")
                # 创建默认文件或提示用户
                
            except PermissionError:
                print(f"没有权限读取文件: {filename}")
                # 请求管理员权限或使用备用文件
                
            except IsADirectoryError:
                print(f"{filename} 是一个目录")
                # 列出目录内容或选择文件
                
            except UnicodeDecodeError:
                print(f"文件编码错误: {filename}")
                # 尝试不同编码或跳过该文件
                
            except OSError as e:
                print(f"操作系统错误: {e.errno} - {e.strerror}")
                # 系统级错误处理
                
            except Exception as e:
                print(f"未知错误: {type(e).__name__}: {e}")
                # 最后防线：记录并重新抛出
                raise
    
    @staticmethod
    def avoid_exceptions_for_flow_control():
        """不要用异常控制流程"""
        
        # 不好的做法 ❌
        def bad_flow_control(data):
            try:
                value = int(data)
                return value
            except ValueError:
                return None  # 这不是异常情况
        
        # 好的做法 ✅
        def good_flow_control(data):
            if data.isdigit():
                return int(data)
            return None
        
        # 实际应用：检查键是否存在
        def check_key_safely(data, key):
            # EAFP风格（Pythonic）
            try:
                return data[key]
            except KeyError:
                return None
            
            # 或者LBYL风格
            # if key in data:
            #     return data[key]
            # return None
        
        print("Python推荐EAFP风格：请求宽恕比许可更容易")
    
    @staticmethod
    def resource_management():
        """资源管理最佳实践"""
        
        # 不好的做法 ❌
        def bad_resource_management():
            file = None
            try:
                file = open("data.txt", "w")
                file.write("数据")
                # ... 更多操作
            finally:
                if file:
                    file.close()  # 容易忘记
        
        # 好的做法 ✅
        def good_resource_management():
            # 使用with语句
            with open("data.txt", "w") as file:
                file.write("数据")
                # ... 更多操作
            # 文件自动关闭
        
        # 自定义资源管理器
        class DatabaseConnection:
            def __init__(self, connection_string):
                self.connection_string = connection_string
                self.connection = None
            
            def __enter__(self):
                print(f"连接到: {self.connection_string}")
                self.connection = f"Connection[{self.connection_string}]"
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                print(f"关闭连接: {self.connection_string}")
                self.connection = None
                # 可以选择抑制异常
                if exc_type:
                    print(f"在上下文中发生异常: {exc_type.__name__}")
                    # 返回True抑制异常，False让异常传播
                return False
            
            def execute(self, query):
                print(f"执行: {query}")
                return "结果"
        
        # 使用
        with DatabaseConnection("localhost:3306/mydb") as db:
            result = db.execute("SELECT * FROM users")
            print(result)
    
    @staticmethod
    def exception_documentation():
        """异常文档化"""
        
        def calculate_statistics(data):
            """
            计算数据的统计信息
            
            Args:
                data: 数值列表
                
            Returns:
                包含统计信息的字典
                
            Raises:
                ValueError: 如果数据为空或包含非数值
                ZeroDivisionError: 如果计算过程中发生除零错误
                TypeError: 如果输入不是列表
            """
            if not isinstance(data, list):
                raise TypeError("输入必须是列表")
            
            if not data:
                raise ValueError("数据列表不能为空")
            
            try:
                # 计算平均值
                average = sum(data) / len(data)
                
                return {
                    "average": average,
                    "min": min(data),
                    "max": max(data)
                }
                
            except TypeError as e:
                raise ValueError("数据必须全部为数值") from e

# 运行最佳实践示例
practices = BestPractices()
practices.specific_over_general()
practices.avoid_exceptions_for_flow_control()
practices.resource_management()
practices.exception_documentation()
```

### 2. 实用的异常处理工具
```python
class ExceptionHandlingUtilities:
    """异常处理实用工具"""
    
    @staticmethod
    def retry_decorator(max_attempts=3, delay=1, exceptions=(Exception,)):
        """重试装饰器"""
        import time
        import functools
        
        def decorator(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                for attempt in range(1, max_attempts + 1):
                    try:
                        return func(*args, **kwargs)
                    except exceptions as e:
                        if attempt == max_attempts:
                            print(f"重试{max_attempts}次后仍然失败")
                            raise
                        print(f"尝试{attempt}失败: {e}, {delay}秒后重试...")
                        time.sleep(delay)
                return None
            return wrapper
        return decorator
    
    @staticmethod
    def safe_execute(func, default=None, exceptions=(Exception,)):
        """安全执行函数"""
        try:
            return func()
        except exceptions as e:
            print(f"安全执行失败: {type(e).__name__}: {e}")
            return default
    
    @staticmethod
    def exception_to_dict(exception):
        """将异常转换为字典"""
        import traceback
        
        return {
            "type": type(exception).__name__,
            "message": str(exception),
            "args": exception.args,
            "traceback": traceback.format_exception(
                type(exception), exception, exception.__traceback__
            ),
            "cause": ExceptionHandlingUtilities.exception_to_dict(exception.__cause__) 
                if exception.__cause__ else None,
            "context": ExceptionHandlingUtilities.exception_to_dict(exception.__context__) 
                if exception.__context__ else None
        }
    
    class SuppressException:
        """抑制异常上下文管理器"""
        def __init__(self, exception_types, default=None):
            self.exception_types = exception_types
            self.default = default
        
        def __enter__(self):
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            if exc_type and issubclass(exc_type, self.exception_types):
                # 抑制异常
                if self.default is not None:
                    return self.default
                return True  # 抑制异常
            return False  # 不抑制异常

# 使用实用工具
utils = ExceptionHandlingUtilities()

# 测试重试装饰器
@utils.retry_decorator(max_attempts=3, delay=0.5, exceptions=(ValueError,))
def unreliable_operation():
    import random
    if random.random() < 0.7:
        raise ValueError("随机失败")
    return "成功"

print("测试重试装饰器:")
for i in range(3):
    try:
        result = unreliable_operation()
        print(f"尝试{i+1}: {result}")
    except ValueError as e:
        print(f"尝试{i+1}: 最终失败: {e}")

# 测试安全执行
print("\n测试安全执行:")
result = utils.safe_execute(
    lambda: 10 / 0,
    default="默认值",
    exceptions=(ZeroDivisionError,)
)
print(f"结果: {result}")

# 测试异常转换
print("\n测试异常转换:")
try:
    x = 1 / 0
except ZeroDivisionError as e:
    exception_dict = utils.exception_to_dict(e)
    print(f"异常字典: {exception_dict}")

# 测试异常抑制
print("\n测试异常抑制:")
with utils.SuppressException((ZeroDivisionError,), default=0):
    result = 10 / 0
    print("这行不会执行")
print(f"结果: {result}")  # 输出: 0
```

---

## 8.9 综合示例

### 示例1：完整的API客户端
```python
class APIClient:
    """API客户端 - 完整的异常处理示例"""
    
    class APIError(Exception):
        """API错误基类"""
        def __init__(self, message, status_code=None, response=None):
            self.message = message
            self.status_code = status_code
            self.response = response
            super().__init__(self.message)
    
    class NetworkError(APIError):
        """网络错误"""
        pass
    
    class TimeoutError(APIError):
        """超时错误"""
        pass
    
    class AuthenticationError(APIError):
        """认证错误"""
        pass
    
    class RateLimitError(APIError):
        """速率限制错误"""
        def __init__(self, message, retry_after):
            self.retry_after = retry_after
            super().__init__(message, 429)
    
    class ValidationError(APIError):
        """验证错误"""
        def __init__(self, message, errors=None):
            self.errors = errors or []
            super().__init__(message, 400)
    
    def __init__(self, base_url, api_key=None, timeout=30):
        self.base_url = base_url
        self.api_key = api_key
        self.timeout = timeout
        self.session = self._create_session()
    
    def _create_session(self):
        """创建会话"""
        import requests
        session = requests.Session()
        session.timeout = self.timeout
        
        if self.api_key:
            session.headers.update({
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            })
        
        return session
    
    def _handle_response(self, response):
        """处理响应"""
        import json
        
        try:
            response.raise_for_status()
            
            # 尝试解析JSON
            try:
                return response.json()
            except json.JSONDecodeError:
                return response.text
                
        except requests.exceptions.HTTPError as e:
            status_code = response.status_code
            
            # 根据状态码抛出不同的异常
            if status_code == 400:
                try:
                    error_data = response.json()
                    errors = error_data.get("errors", [])
                    raise self.ValidationError("请求验证失败", errors)
                except json.JSONDecodeError:
                    raise self.APIError(f"请求错误: {response.text}", status_code)
                    
            elif status_code == 401:
                raise self.AuthenticationError("认证失败", status_code)
                
            elif status_code == 403:
                raise self.APIError("权限不足", status_code)
                
            elif status_code == 404:
                raise self.APIError("资源未找到", status_code)
                
            elif status_code == 429:
                retry_after = response.headers.get("Retry-After", 60)
                raise self.RateLimitError("速率限制超出", retry_after)
                
            elif 500 <= status_code < 600:
                raise self.APIError(f"服务器错误: {status_code}", status_code)
                
            else:
                raise self.APIError(f"HTTP错误: {status_code}", status_code)
    
    def request(self, method, endpoint, **kwargs):
        """发送请求"""
        import requests
        import time
        
        url = f"{self.base_url}{endpoint}"
        
        for attempt in range(3):  # 最多重试3次
            try:
                print(f"发送请求: {method} {url} (尝试 {attempt + 1}/3)")
                
                response = self.session.request(method, url, **kwargs)
                return self._handle_response(response)
                
            except requests.exceptions.ConnectionError as e:
                print(f"连接错误: {e}")
                if attempt == 2:  # 最后一次尝试
                    raise self.NetworkError(f"无法连接到服务器: {e}")
                time.sleep(1)  # 等待1秒后重试
                
            except requests.exceptions.Timeout as e:
                print(f"超时错误: {e}")
                if attempt == 2:
                    raise self.TimeoutError(f"请求超时: {e}")
                time.sleep(1)
                
            except requests.exceptions.RequestException as e:
                print(f"请求错误: {e}")
                raise self.APIError(f"请求失败: {e}")
                
            except self.RateLimitError as e:
                print(f"速率限制: 等待{e.retry_after}秒")
                time.sleep(e.retry_after)
                continue  # 重试
                
            except self.APIError:
                raise  # 重新抛出API错误
                
            except Exception as e:
                print(f"未知错误: {type(e).__name__}: {e}")
                raise self.APIError(f"未知错误: {e}")
    
    def get(self, endpoint, **kwargs):
        """GET请求"""
        return self.request("GET", endpoint, **kwargs)
    
    def post(self, endpoint, data=None, **kwargs):
        """POST请求"""
        return self.request("POST", endpoint, json=data, **kwargs)
    
    def put(self, endpoint, data=None, **kwargs):
        """PUT请求"""
        return self.request("PUT", endpoint, json=data, **kwargs)
    
    def delete(self, endpoint, **kwargs):
        """DELETE请求"""
        return self.request("DELETE", endpoint, **kwargs)

# 使用示例（需要requests库）
def api_client_demo():
    """API客户端演示"""
    try:
        # 创建客户端
        client = APIClient(
            base_url="https://api.example.com",
            api_key="test_api_key"
        )
        
        # 获取用户信息
        user_data = client.get("/users/123")
        print(f"用户数据: {user_data}")
        
        # 创建新用户
        new_user = {"name": "John", "email": "john@example.com"}
        created_user = client.post("/users", data=new_user)
        print(f"创建的用户: {created_user}")
        
        # 更新用户
        updated_data = {"name": "John Updated"}
        updated_user = client.put("/users/123", data=updated_data)
        print(f"更新的用户: {updated_user}")
        
        # 删除用户
        client.delete("/users/123")
        print("用户已删除")
        
    except APIClient.ValidationError as e:
        print(f"验证错误: {e}")
        print(f"详细错误: {e.errors}")
        
    except APIClient.AuthenticationError as e:
        print(f"认证错误: {e}")
        print("请检查API密钥")
        
    except APIClient.RateLimitError as e:
        print(f"速率限制: 请等待{e.retry_after}秒后重试")
        
    except APIClient.NetworkError as e:
        print(f"网络错误: {e}")
        print("请检查网络连接")
        
    except APIClient.APIError as e:
        print(f"API错误 [{e.status_code}]: {e}")
        
    except Exception as e:
        print(f"未知错误: {type(e).__name__}: {e}")
        import traceback
        traceback.print_exc()

# 注意：这是一个示例，实际运行需要真实的API端点
# api_client_demo()
```

### 示例2：数据库事务管理器
```python
class DatabaseTransactionManager:
    """数据库事务管理器 - 综合异常处理示例"""
    
    class DatabaseError(Exception):
        """数据库错误基类"""
        def __init__(self, message, sql=None, params=None):
            self.message = message
            self.sql = sql
            self.params = params
            super().__init__(self.message)
    
    class ConnectionError(DatabaseError):
        """连接错误"""
        pass
    
    class QueryError(DatabaseError):
        """查询错误"""
        pass
    
    class TransactionError(DatabaseError):
        """事务错误"""
        pass
    
    class ConstraintError(DatabaseError):
        """约束错误"""
        def __init__(self, message, constraint_name):
            self.constraint_name = constraint_name
            super().__init__(message)
    
    def __init__(self, connection_string):
        self.connection_string = connection_string
        self.connection = None
        self.transaction_depth = 0
    
    def __enter__(self):
        """进入上下文"""
        self.connect()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文"""
        try:
            if exc_type:
                # 有异常发生，回滚事务
                self.rollback()
            else:
                # 无异常，提交事务
                self.commit()
        finally:
            # 无论如何都关闭连接
            self.disconnect()
        
        # 返回False让异常继续传播
        return False
    
    def connect(self):
        """连接数据库"""
        try:
            print(f"连接到数据库: {self.connection_string}")
            # 模拟数据库连接
            import random
            if random.random() < 0.1:
                raise self.ConnectionError("连接超时")
            
            self.connection = f"Connection[{self.connection_string}]"
            print("连接成功")
            
        except self.ConnectionError as e:
            print(f"连接失败: {e}")
            raise
        except Exception as e:
            raise self.ConnectionError(f"连接失败: {e}")
    
    def disconnect(self):
        """断开连接"""
        if self.connection:
            print(f"断开数据库连接")
            self.connection = None
    
    def begin_transaction(self):
        """开始事务"""
        try:
            if self.transaction_depth == 0:
                print("开始事务")
            self.transaction_depth += 1
            print(f"事务深度: {self.transaction_depth}")
            
        except Exception as e:
            raise self.TransactionError(f"开始事务失败: {e}")
    
    def commit(self):
        """提交事务"""
        try:
            if self.transaction_depth > 0:
                self.transaction_depth -= 1
                print(f"提交事务，剩余深度: {self.transaction_depth}")
                
                if self.transaction_depth == 0:
                    print("事务已提交")
                    
        except Exception as e:
            raise self.TransactionError(f"提交事务失败: {e}")
    
    def rollback(self):
        """回滚事务"""
        try:
            print("回滚事务")
            self.transaction_depth = 0
            
        except Exception as e:
            raise self.TransactionError(f"回滚事务失败: {e}")
    
    def execute_query(self, sql, params=None):
        """执行查询"""
        try:
            if not self.connection:
                raise self.ConnectionError("数据库未连接")
            
            print(f"执行SQL: {sql}")
            if params:
                print(f"参数: {params}")
            
            # 模拟查询执行
            import random
            
            # 模拟约束错误
            if "INSERT" in sql.upper() and random.random() < 0.2:
                raise self.ConstraintError("唯一约束冲突", "unique_email")
            
            # 模拟查询错误
            if "SELECT" in sql.upper() and random.random() < 0.1:
                raise self.QueryError("语法错误", sql, params)
            
            # 模拟成功
            return {"rows": 1, "data": ["result"]}
            
        except self.ConstraintError as e:
            print(f"约束错误: {e.constraint_name}")
            raise
            
        except self.QueryError as e:
            print(f"查询错误: SQL={e.sql}, Params={e.params}")
            raise
            
        except Exception as e:
            raise self.DatabaseError(f"查询执行失败: {e}", sql, params)
    
    def execute_in_transaction(self, operations):
        """在事务中执行多个操作"""
        try:
            self.begin_transaction()
            
            results = []
            for i, (sql, params) in enumerate(operations):
                try:
                    result = self.execute_query(sql, params)
                    results.append(result)
                    
                except self.ConstraintError as e:
                    print(f"操作{i+1}违反约束，回滚事务")
                    self.rollback()
                    raise
                    
                except self.DatabaseError as e:
                    print(f"操作{i+1}失败，回滚事务")
                    self.rollback()
                    raise
            
            self.commit()
            return results
            
        except self.DatabaseError:
            raise  # 重新抛出
        except Exception as e:
            self.rollback()
            raise self.TransactionError(f"事务执行失败: {e}")

# 使用示例
def transaction_manager_demo():
    """事务管理器演示"""
    
    # 使用上下文管理器
    print("=== 使用上下文管理器 ===")
    try:
        with DatabaseTransactionManager("postgresql://localhost/mydb") as db:
            # 在事务中执行操作
            operations = [
                ("INSERT INTO users (name, email) VALUES (%s, %s)", ("Alice", "alice@example.com")),
                ("UPDATE accounts SET balance = balance - %s WHERE user_id = %s", (100, 1)),
                ("UPDATE accounts SET balance = balance + %s WHERE user_id = %s", (100, 2))
            ]
            
            results = db.execute_in_transaction(operations)
            print(f"事务执行成功: {len(results)} 个操作")
            
    except DatabaseTransactionManager.ConstraintError as e:
        print(f"约束错误: {e.constraint_name}")
        
    except DatabaseTransactionManager.TransactionError as e:
        print(f"事务错误: {e}")
        
    except DatabaseTransactionManager.DatabaseError as e:
        print(f"数据库错误: {e}")
        if e.sql:
            print(f"SQL: {e.sql}")
        
    except Exception as e:
        print(f"未知错误: {type(e).__name__}: {e}")
    
    # 手动管理事务
    print("\n=== 手动管理事务 ===")
    db = DatabaseTransactionManager("postgresql://localhost/mydb")
    
    try:
        db.connect()
        db.begin_transaction()
        
        result1 = db.execute_query("SELECT * FROM users WHERE id = %s", (1,))
        print(f"查询1结果: {result1}")
        
        result2 = db.execute_query("UPDATE users SET name = %s WHERE id = %s", ("Bob", 1))
        print(f"查询2结果: {result2}")
        
        db.commit()
        print("事务提交成功")
        
    except DatabaseTransactionManager.DatabaseError as e:
        print(f"数据库错误，回滚事务: {e}")
        db.rollback()
        
    except Exception as e:
        print(f"未知错误: {e}")
        db.rollback()
        
    finally:
        db.disconnect()

# 运行演示
# transaction_manager_demo()
```

---

## 8.10 本章练习

### 练习1：基础异常处理
1. 创建一个 `SafeCalculator` 类，包含以下方法：
   - `divide(a, b)`: 安全除法，处理除零错误
   - `square_root(n)`: 计算平方根，处理负数输入
   - `parse_number(s)`: 安全解析字符串为数字

2. 创建一个 `FileProcessor` 类，包含以下方法：
   - `read_file(filename)`: 安全读取文件，处理各种文件错误
   - `write_file(filename, content)`: 安全写入文件，处理权限错误

### 练习2：自定义异常
1. 创建一个 `ShoppingSystem` 系统，包含以下自定义异常：
   - `ShoppingError`: 购物系统错误基类
   - `ProductNotFoundError`: 商品未找到错误
   - `InsufficientStockError`: 库存不足错误
   - `InvalidQuantityError`: 无效数量错误
   - `PaymentFailedError`: 支付失败错误

2. 实现购物车、库存管理、支付处理等功能，并抛出相应的异常

### 练习3：异常链
1. 创建一个 `DataPipeline` 类，处理数据流程：
   - 读取数据 → 验证数据 → 转换数据 → 保存数据
   - 每个步骤都可能失败，使用异常链传递错误信息
   - 实现错误恢复和重试机制

### 练习4：资源管理
1. 创建一个 `ResourcePool` 类，管理数据库连接池：
   - 使用上下文管理器管理连接获取和释放
   - 处理连接超时、连接中断等异常
   - 实现连接的健康检查和自动重连

### 练习5：装饰器应用
1. 创建一个 `@retry` 装饰器，支持以下功能：
   - 指定重试次数和延迟时间
   - 指定要重试的异常类型
   - 支持指数退避策略
   - 支持自定义重试条件

2. 创建一个 `@circuit_breaker` 装饰器，实现熔断器模式

### 练习6：综合项目 - 邮件发送系统
创建一个邮件发送系统，包含以下功能：

1. **邮件构建**：
   - 验证收件人、发件人格式
   - 验证邮件内容（大小、格式）
   - 处理附件

2. **邮件发送**：
   - 支持SMTP发送
   - 处理发送失败（网络问题、服务器问题）
   - 实现发送队列和重试机制

3. **错误处理**：
   - `EmailValidationError`: 邮件验证错误
   - `EmailSendError`: 邮件发送错误
   - `AttachmentError`: 附件处理错误

4. **监控和日志**：
   - 记录发送成功和失败
   - 统计发送成功率
   - 提供错误报告

### 练习7：代码调试和优化
找出以下代码中的问题并优化：

```python
# 问题代码1
def process_user_data(user_data):
    try:
        name = user_data['name']
        age = user_data['age']
        email = user_data['email']
        
        # 处理数据...
        result = f"{name} ({age}): {email}"
        return result
    except:
        return "错误：数据格式不正确"

# 问题代码2
class Database:
    def query(self, sql):
        conn = None
        try:
            conn = self.connect()
            cursor = conn.cursor()
            cursor.execute(sql)
            return cursor.fetchall()
        except Exception as e:
            print(f"查询错误: {e}")
        finally:
            if conn:
                conn.close()

# 问题代码3
def calculate_statistics(data):
    stats = {}
    try:
        stats['mean'] = sum(data) / len(data)
        stats['median'] = sorted(data)[len(data) // 2]
        stats['std'] = (sum((x - stats['mean']) ** 2 for x in data) / len(data)) ** 0.5
    except ZeroDivisionError:
        stats['mean'] = 0
        stats['median'] = 0
        stats['std'] = 0
    return stats
```

### 参考答案提示
1. 问题代码1：捕获异常过于宽泛，应该具体指定异常类型
2. 问题代码2：资源管理不够安全，应该使用上下文管理器
3. 问题代码3：没有处理空列表和非数值数据的情况

---

## 总结

本章中，你学习了：

### 核心概念
- ✅ **错误与异常的区别**：语法错误 vs 运行时异常
- ✅ **异常处理机制**：try-except-else-finally 完整结构
- ✅ **异常类型体系**：Python内置异常的层次结构

### 关键技术
- ✅ **异常捕获**：具体异常捕获、多个异常处理
- ✅ **资源管理**：finally子句、with语句、上下文管理器
- ✅ **异常信息**：获取异常对象、堆栈跟踪、自定义属性

### 高级特性
- ✅ **自定义异常**：创建有意义的异常类体系
- ✅ **异常链**：使用raise...from传递原始异常
- ✅ **异常上下文**：添加上下文信息便于调试

### 最佳实践
- ✅ **具体化异常处理**：避免捕获过于宽泛的异常
- ✅ **合理使用异常**：不用异常控制正常流程
- ✅ **资源安全释放**：确保文件、连接等资源被正确清理
- ✅ **错误信息友好**：向用户提供清晰有用的错误信息

### 设计模式
- ✅ **错误包装器**：将底层异常包装为应用层异常
- ✅ **重试机制**：处理临时性故障
- ✅ **熔断器模式**：防止系统过载
- ✅ **降级策略**：在主功能失败时提供备用方案

### 关键要点
1. **防御性编程**：始终考虑可能发生的错误
2. **优雅降级**：在错误发生时提供合理的用户体验
3. **错误传播**：在适当的层级处理错误
4. **可观测性**：记录足够的错误信息以便调试
5. **可维护性**：使错误处理代码清晰易懂

### 编程建议
- 为库和框架定义清晰的异常接口
- 在文档中说明可能抛出的异常
- 使用类型注解提示可能抛出的异常
- 编写单元测试覆盖错误路径
- 记录生产环境中的错误以便分析改进

### 面向对象视角
在面向对象编程中，异常处理体现了以下OOP原则：
- **封装**：将错误处理逻辑封装在类和方法中
- **继承**：创建异常类层次结构，实现代码复用
- **多态**：通过异常基类统一处理不同类型的错误
- **抽象**：定义清晰的错误接口和规范

---

## 扩展知识
- [Python 异常处理官方文档](https://docs.python.org/zh-cn/3/tutorial/errors.html)
- [Python 内置异常](https://docs.python.org/zh-cn/3/library/exceptions.html)
- [Python 日志记录](https://docs.python.org/zh-cn/3/library/logging.html)
- [Python 断言](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#the-assert-statement)
- [EAFP vs LBYL编程风格](https://docs.python.org/zh-cn/3/glossary.html#term-eafp)

**下一章**：[第9章：模块和包]

> 如果有任何问题，欢迎提问！