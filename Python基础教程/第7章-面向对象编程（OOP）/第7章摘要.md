# 第7章：面向对象编程 (OOP)

## 目录
- [7.1 面向对象编程概述](#71-面向对象编程概述)
- [7.2 类与对象](#72-类与对象)
- [7.3 类的属性和方法](#73-类的属性和方法)
  - [7.3.1 实例属性和方法](#731-实例属性和方法)
  - [7.3.2 类属性和方法](#732-类属性和方法)
  - [7.3.3 静态方法](#733-静态方法)
- [7.4 构造函数和析构函数](#74-构造函数和析构函数)
- [7.5 封装](#75-封装)
- [7.6 继承](#76-继承)
  - [7.6.1 单继承](#761-单继承)
  - [7.6.2 多继承](#762-多继承)
  - [7.6.3 方法重写](#763-方法重写)
- [7.7 多态](#77-多态)
- [7.8 特殊方法（魔术方法）](#78-特殊方法魔术方法)
- [7.9 抽象类和接口](#79-抽象类和接口)
- [7.10 综合示例](#710-综合示例)
- [7.11 本章练习](#711-本章练习)

---

## 7.1 面向对象编程概述

### 什么是面向对象编程？
**面向对象编程（Object-Oriented Programming, OOP）** 是一种编程范式，它将程序组织为对象的集合，每个对象都包含数据和操作数据的方法。

### OOP 的四大特性
1. **封装（Encapsulation）**：隐藏对象的内部实现细节，只暴露必要的接口
2. **继承（Inheritance）**：子类可以继承父类的属性和方法，实现代码复用
3. **多态（Polymorphism）**：同一操作作用于不同的对象，可以有不同的解释和执行结果
4. **抽象（Abstraction）**：提取对象的共同特征，形成抽象概念

### 面向对象 vs 面向过程
```python
# 面向过程的方式 - 关注步骤和函数
def calculate_area(radius):
    """计算圆的面积"""
    return 3.14 * radius ** 2

def calculate_perimeter(radius):
    """计算圆的周长"""
    return 2 * 3.14 * radius

# 使用
radius = 5
area = calculate_area(radius)
perimeter = calculate_perimeter(radius)
print(f"半径 {radius} 的圆: 面积={area}, 周长={perimeter}")

# 面向对象的方式 - 关注对象和它们的行为
class Circle:
    """圆类"""
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        """计算面积"""
        return 3.14 * self.radius ** 2
    
    def perimeter(self):
        """计算周长"""
        return 2 * 3.14 * self.radius

# 使用
circle = Circle(5)  # 创建一个圆对象
print(f"半径 {circle.radius} 的圆: 面积={circle.area()}, 周长={circle.perimeter()}")
```

### OOP 的优势
1. **模块化**：代码更易于理解和维护
2. **代码复用**：通过继承减少重复代码
3. **灵活性**：通过多态增加程序的灵活性
4. **易维护性**：修改影响范围小，易于调试和测试

---

## 7.2 类与对象

### 类和对象的关系
- **类（Class）**：是对象的蓝图或模板，定义了对象的属性和方法
- **对象（Object）**：是类的实例，具有类定义的属性和方法

```python
# 定义一个简单的类
class Dog:
    """狗类"""
    
    # 类属性（所有实例共享）
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        """初始化方法（构造函数）"""
        # 实例属性（每个实例独有）
        self.name = name
        self.age = age
    
    def bark(self):
        """狗叫的方法"""
        return f"{self.name} 在汪汪叫！"
    
    def get_info(self):
        """获取狗的信息"""
        return f"名字: {self.name}, 年龄: {self.age}岁, 种类: {self.species}"

# 创建对象（实例化）
dog1 = Dog("旺财", 3)
dog2 = Dog("小白", 2)

# 访问对象的属性和方法
print(dog1.name)           # 旺财
print(dog1.age)            # 3
print(dog1.bark())         # 旺财 在汪汪叫！
print(dog1.get_info())     # 名字: 旺财, 年龄: 3岁, 种类: Canis familiaris

print(dog2.bark())         # 小白 在汪汪叫！

# 访问类属性
print(f"狗的种类: {Dog.species}")  # Canis familiaris
print(f"旺财的种类: {dog1.species}")  # Canis familiaris

# 修改实例属性
dog1.age = 4
print(f"旺财的新年龄: {dog1.age}")  # 4

# 修改类属性（会影响所有实例）
Dog.species = "犬科动物"
print(f"狗的新种类: {Dog.species}")  # 犬科动物
print(f"小白的种类: {dog2.species}")  # 犬科动物
```

### 类的基本结构
```python
class ClassName:
    """类的文档字符串"""
    
    # 类属性
    class_attribute = "类属性值"
    
    def __init__(self, param1, param2):
        """初始化方法"""
        # 实例属性
        self.instance_attr1 = param1
        self.instance_attr2 = param2
    
    def instance_method(self):
        """实例方法"""
        # 方法体
        pass
    
    @classmethod
    def class_method(cls):
        """类方法"""
        pass
    
    @staticmethod
    def static_method():
        """静态方法"""
        pass
```

### 查看类的信息
```python
class Student:
    """学生类"""
    school = "清华大学"
    
    def __init__(self, name, student_id, major):
        self.name = name
        self.student_id = student_id
        self.major = major
    
    def study(self, course):
        return f"{self.name} 正在学习 {course}"
    
    def get_info(self):
        return f"姓名: {self.name}, 学号: {self.student_id}, 专业: {self.major}"

# 创建对象
student = Student("张三", "20230001", "计算机科学")

# 查看对象和类的信息
print(f"对象类型: {type(student)}")                    # <class '__main__.Student'>
print(f"是否是Student类的实例: {isinstance(student, Student)}")  # True
print(f"类的名称: {Student.__name__}")                # Student
print(f"类的文档字符串: {Student.__doc__}")          # 学生类
print(f"类的模块: {Student.__module__}")             # __main__
print(f"类的字典（包含所有属性）: {Student.__dict__.keys()}")  # dict_keys(['__module__', '__doc__', ...])

# 查看对象的属性
print(f"对象属性: {student.__dict__}")                # {'name': '张三', 'student_id': '20230001', 'major': '计算机科学'}

# 使用内置函数
print(f"对象的所有属性: {dir(student)[:10]}")        # 显示前10个属性
```

---

## 7.3 类的属性和方法

### 7.3.1 实例属性和方法
实例属性和方法属于对象，每个对象都有自己独立的副本。

```python
class Car:
    """汽车类"""
    
    def __init__(self, brand, model, year):
        """初始化实例属性"""
        self.brand = brand      # 实例属性
        self.model = model      # 实例属性
        self.year = year        # 实例属性
        self.odometer = 0       # 实例属性，默认值为0
    
    def describe(self):
        """实例方法 - 返回汽车描述"""
        return f"{self.year}年 {self.brand} {self.model}"
    
    def drive(self, miles):
        """实例方法 - 模拟驾驶，更新里程表"""
        self.odometer += miles
        return f"已行驶 {miles} 公里，总里程: {self.odometer} 公里"
    
    def get_odometer(self):
        """实例方法 - 获取当前里程"""
        return self.odometer

# 创建多个汽车对象
car1 = Car("丰田", "凯美瑞", 2022)
car2 = Car("本田", "雅阁", 2023)

# 每个对象有独立的属性
print(f"car1: {car1.describe()}")  # 2022年 丰田 凯美瑞
print(f"car2: {car2.describe()}")  # 2023年 本田 雅阁

# 调用实例方法
print(car1.drive(100))  # 已行驶 100 公里，总里程: 100 公里
print(car1.drive(50))   # 已行驶 50 公里，总里程: 150 公里
print(car2.drive(80))   # 已行驶 80 公里，总里程: 80 公里

# 每个对象的里程表是独立的
print(f"car1里程: {car1.get_odometer()}")  # 150
print(f"car2里程: {car2.get_odometer()}")  # 80

# 修改实例属性
car1.year = 2024
print(f"car1更新年份后: {car1.describe()}")  # 2024年 丰田 凯美瑞
```

### 7.3.2 类属性和方法
类属性和方法属于类本身，所有实例共享。

```python
class BankAccount:
    """银行账户类"""
    
    # 类属性
    bank_name = "中国银行"
    interest_rate = 0.0035  # 年利率 0.35%
    total_accounts = 0      # 总账户数
    
    def __init__(self, account_holder, initial_balance=0):
        """初始化实例"""
        # 实例属性
        self.account_holder = account_holder
        self.balance = initial_balance
        self.account_number = self._generate_account_number()
        
        # 更新类属性
        BankAccount.total_accounts += 1
    
    def _generate_account_number(self):
        """生成账户号（类方法更合适，这里只是演示）"""
        import random
        return f"{BankAccount.bank_name[:2]}{random.randint(100000, 999999)}"
    
    @classmethod
    def get_bank_info(cls):
        """类方法 - 获取银行信息"""
        return f"银行名称: {cls.bank_name}, 利率: {cls.interest_rate}, 总账户数: {cls.total_accounts}"
    
    @classmethod
    def set_interest_rate(cls, new_rate):
        """类方法 - 设置利率"""
        cls.interest_rate = new_rate
        print(f"利率已更新为: {new_rate}")
    
    def deposit(self, amount):
        """实例方法 - 存款"""
        if amount > 0:
            self.balance += amount
            print(f"成功存入 {amount} 元，当前余额: {self.balance} 元")
        else:
            print("存款金额必须大于0")
        return self.balance
    
    def withdraw(self, amount):
        """实例方法 - 取款"""
        if amount > self.balance:
            print(f"余额不足！当前余额: {self.balance} 元")
        elif amount <= 0:
            print("取款金额必须大于0")
        else:
            self.balance -= amount
            print(f"成功取出 {amount} 元，当前余额: {self.balance} 元")
        return self.balance
    
    def calculate_interest(self):
        """实例方法 - 计算利息"""
        interest = self.balance * BankAccount.interest_rate
        return interest
    
    def get_account_info(self):
        """实例方法 - 获取账户信息"""
        return f"""
        账户信息:
        银行: {BankAccount.bank_name}
        户主: {self.account_holder}
        账号: {self.account_number}
        余额: {self.balance:.2f} 元
        预计年利息: {self.calculate_interest():.2f} 元
        """

# 使用类方法（不需要创建实例）
print(BankAccount.get_bank_info())  # 银行名称: 中国银行, 利率: 0.0035, 总账户数: 0

# 创建账户
account1 = BankAccount("张三", 10000)
account2 = BankAccount("李四", 5000)

print(f"创建账户后总账户数: {BankAccount.total_accounts}")  # 2

# 访问类属性
print(f"银行名称: {BankAccount.bank_name}")        # 中国银行
print(f"account1的银行名称: {account1.bank_name}")  # 中国银行

# 使用类方法修改类属性
BankAccount.set_interest_rate(0.004)  # 利率已更新为: 0.004

# 所有实例都会受到影响
print(f"account1的新利率: {account1.interest_rate}")  # 0.004
print(f"account2的新利率: {account2.interest_rate}")  # 0.004

# 实例操作
account1.deposit(2000)    # 成功存入 2000 元，当前余额: 12000 元
account1.withdraw(3000)   # 成功取出 3000 元，当前余额: 9000 元

print(account1.get_account_info())
print(account2.get_account_info())
```

### 7.3.3 静态方法
静态方法不需要访问类或实例，类似于普通函数，但逻辑上属于类。

```python
class MathUtils:
    """数学工具类"""
    
    @staticmethod
    def add(a, b):
        """静态方法 - 加法"""
        return a + b
    
    @staticmethod
    def multiply(a, b):
        """静态方法 - 乘法"""
        return a * b
    
    @staticmethod
    def factorial(n):
        """静态方法 - 阶乘"""
        if n < 0:
            raise ValueError("阶乘不支持负数")
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result
    
    @staticmethod
    def is_prime(n):
        """静态方法 - 判断是否为质数"""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        
        return True

# 使用静态方法（不需要创建实例）
print(f"5 + 3 = {MathUtils.add(5, 3)}")           # 8
print(f"5 × 3 = {MathUtils.multiply(5, 3)}")      # 15
print(f"5! = {MathUtils.factorial(5)}")           # 120
print(f"17是质数吗? {MathUtils.is_prime(17)}")    # True
print(f"15是质数吗? {MathUtils.is_prime(15)}")    # False

# 也可以创建实例后使用，但不推荐
utils = MathUtils()
print(f"通过实例调用: {utils.add(2, 3)}")         # 5

# 实际应用：日期验证
class DateValidator:
    """日期验证工具类"""
    
    @staticmethod
    def is_valid_date(date_str):
        """验证日期字符串格式是否为 YYYY-MM-DD"""
        import re
        pattern = r'^\d{4}-\d{2}-\d{2}$'
        if not re.match(pattern, date_str):
            return False
        
        # 进一步验证日期是否有效
        try:
            import datetime
            datetime.datetime.strptime(date_str, '%Y-%m-%d')
            return True
        except ValueError:
            return False
    
    @staticmethod
    def is_leap_year(year):
        """判断是否为闰年"""
        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)
    
    @staticmethod
    def get_days_in_month(year, month):
        """获取指定月份的天数"""
        if month in [1, 3, 5, 7, 8, 10, 12]:
            return 31
        elif month in [4, 6, 9, 11]:
            return 28
        elif month == 2:
            return 29 if DateValidator.is_leap_year(year) else 28
        else:
            raise ValueError("无效的月份")

# 使用
print(f"'2024-05-20' 是有效日期吗? {DateValidator.is_valid_date('2024-05-20')}")  # True
print(f"'2024-13-01' 是有效日期吗? {DateValidator.is_valid_date('2024-13-01')}")  # False
print(f"2024年是闰年吗? {DateValidator.is_leap_year(2024)}")                     # True
print(f"2024年2月有几天? {DateValidator.get_days_in_month(2024, 2)}")             # 29

# 对比：实例方法、类方法、静态方法
class Example:
    """演示三种方法的区别"""
    
    class_attr = "类属性"
    
    def __init__(self, value):
        self.instance_attr = value
    
    def instance_method(self):
        """实例方法 - 可以访问实例和类"""
        print(f"实例方法: instance_attr={self.instance_attr}, class_attr={self.class_attr}")
    
    @classmethod
    def class_method(cls):
        """类方法 - 可以访问类，不能访问实例"""
        print(f"类方法: 类名={cls.__name__}, class_attr={cls.class_attr}")
        # print(f"无法访问: {self.instance_attr}")  # 错误！
    
    @staticmethod
    def static_method():
        """静态方法 - 不能访问实例或类"""
        print("静态方法: 我就像一个普通函数")
        # print(f"无法访问: {self.instance_attr}")  # 错误！
        # print(f"无法访问: {cls.class_attr}")      # 错误！

# 使用
example = Example("实例值")

example.instance_method()  # 实例方法: instance_attr=实例值, class_attr=类属性
Example.class_method()     # 类方法: 类名=Example, class_attr=类属性
Example.static_method()    # 静态方法: 我就像一个普通函数
```

---

## 7.4 构造函数和析构函数

### 构造函数 `__init__()`
构造函数在创建对象时自动调用，用于初始化对象的属性。

```python
class Book:
    """图书类"""
    
    def __init__(self, title, author, isbn, price=0.0):
        """构造函数 - 初始化图书属性"""
        self.title = title
        self.author = author
        self.isbn = isbn
        self.price = price
        self.is_available = True  # 默认可用
        self.borrower = None      # 借阅者
        
        print(f"创建图书: 《{self.title}》")
    
    def __str__(self):
        """字符串表示"""
        status = "可借" if self.is_available else f"已借给 {self.borrower}"
        return f"《{self.title}》 - {self.author} [ISBN: {self.isbn}] 价格: ¥{self.price} 状态: {status}"
    
    def borrow(self, borrower_name):
        """借阅图书"""
        if self.is_available:
            self.is_available = False
            self.borrower = borrower_name
            print(f"《{self.title}》已被 {borrower_name} 借走")
            return True
        else:
            print(f"《{self.title}》已被 {self.borrower} 借走，暂时不可借")
            return False
    
    def return_book(self):
        """归还图书"""
        if not self.is_available:
            print(f"《{self.title}》已归还，感谢 {self.borrower}")
            self.is_available = True
            self.borrower = None
            return True
        else:
            print(f"《{self.title}》本来就在图书馆")
            return False

# 创建图书对象
book1 = Book("Python编程从入门到实践", "Eric Matthes", "978-7-115-42802-8", 89.0)
book2 = Book("深度学习", "Ian Goodfellow", "978-7-121-32107-4", 168.0)

print(book1)  # 《Python编程从入门到实践》 - Eric Matthes [ISBN: 978-7-115-42802-8] 价格: ¥89.0 状态: 可借
print(book2)  # 《深度学习》 - Ian Goodfellow [ISBN: 978-7-121-32107-4] 价格: ¥168.0 状态: 可借

# 借阅图书
book1.borrow("张三")  # 《Python编程从入门到实践》已被 张三 借走
print(book1)  # 状态: 已借给 张三

book1.borrow("李四")  # 《Python编程从入门到实践》已被 张三 借走，暂时不可借

# 归还图书
book1.return_book()  # 《Python编程从入门到实践》已归还，感谢 张三
print(book1)  # 状态: 可借
```

### 析构函数 `__del__()`
析构函数在对象被销毁时自动调用，用于清理资源。

```python
class FileHandler:
    """文件处理器类"""
    
    def __init__(self, filename):
        """构造函数 - 打开文件"""
        self.filename = filename
        self.file = open(filename, 'a', encoding='utf-8')
        print(f"打开文件: {filename}")
    
    def write(self, content):
        """写入文件"""
        self.file.write(content + '\n')
        print(f"写入内容: {content}")
    
    def close(self):
        """手动关闭文件"""
        if self.file:
            self.file.close()
            self.file = None
            print(f"关闭文件: {self.filename}")
    
    def __del__(self):
        """析构函数 - 确保文件被关闭"""
        if hasattr(self, 'file') and self.file:
            self.file.close()
            print(f"析构函数关闭文件: {self.filename}")
    
    def __enter__(self):
        """上下文管理器入口"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """上下文管理器出口"""
        self.close()

# 使用析构函数
def test_destructor():
    """测试析构函数"""
    handler = FileHandler("test.txt")
    handler.write("第一行")
    handler.write("第二行")
    # 函数结束时，handler对象会被销毁，自动调用__del__

test_destructor()
# 输出:
# 打开文件: test.txt
# 写入内容: 第一行
# 写入内容: 第二行
# 析构函数关闭文件: test.txt

# 更好的方式：使用上下文管理器（with语句）
print("\n使用上下文管理器:")
with FileHandler("test2.txt") as f:
    f.write("使用with语句")
    f.write("自动管理资源")
# with语句结束时自动调用close()
# 输出:
# 打开文件: test2.txt
# 写入内容: 使用with语句
# 写入内容: 自动管理资源
# 关闭文件: test2.txt

# 实际应用：数据库连接
class DatabaseConnection:
    """数据库连接类"""
    
    def __init__(self, host, port, database):
        """构造函数 - 建立连接"""
        self.host = host
        self.port = port
        self.database = database
        self.connection = None
        self.connect()
    
    def connect(self):
        """连接数据库"""
        print(f"连接到数据库: {self.host}:{self.port}/{self.database}")
        # 模拟连接
        self.connection = f"connection_to_{self.database}"
        self.is_connected = True
    
    def execute_query(self, query):
        """执行查询"""
        if self.is_connected:
            print(f"执行查询: {query}")
            return f"result_of_{query}"
        else:
            raise ConnectionError("数据库未连接")
    
    def close(self):
        """关闭连接"""
        if self.is_connected:
            print(f"关闭数据库连接: {self.database}")
            self.connection = None
            self.is_connected = False
    
    def __del__(self):
        """析构函数 - 确保连接被关闭"""
        if hasattr(self, 'is_connected') and self.is_connected:
            self.close()
            print(f"析构函数关闭数据库连接")

# 使用
db = DatabaseConnection("localhost", 3306, "mydb")
db.execute_query("SELECT * FROM users")
# 程序结束或对象被删除时自动关闭连接
```

### 完整的生命周期示例
```python
class LifecycleDemo:
    """演示对象生命周期"""
    
    instance_count = 0  # 类属性，统计实例数量
    
    def __init__(self, name):
        """构造函数"""
        self.name = name
        LifecycleDemo.instance_count += 1
        print(f"构造函数: 创建 {self.name}，总实例数: {LifecycleDemo.instance_count}")
    
    def __str__(self):
        """字符串表示"""
        return f"LifecycleDemo对象: {self.name}"
    
    def __repr__(self):
        """官方字符串表示"""
        return f"LifecycleDemo('{self.name}')"
    
    def __del__(self):
        """析构函数"""
        LifecycleDemo.instance_count -= 1
        print(f"析构函数: 销毁 {self.name}，剩余实例数: {LifecycleDemo.instance_count}")
    
    def say_hello(self):
        """实例方法"""
        print(f"{self.name} 说: 你好！")

# 演示生命周期
print("开始演示对象生命周期:")
print(f"初始实例数: {LifecycleDemo.instance_count}")  # 0

# 创建对象
obj1 = LifecycleDemo("对象1")
obj2 = LifecycleDemo("对象2")
obj3 = LifecycleDemo("对象3")

print(f"当前实例数: {LifecycleDemo.instance_count}")  # 3

# 使用对象
obj1.say_hello()
obj2.say_hello()

# 删除对象引用
print("\n删除对象引用:")
del obj2  # 显式删除，触发析构函数
print(f"删除后实例数: {LifecycleDemo.instance_count}")  # 2

# 创建新对象
obj4 = LifecycleDemo("对象4")
print(f"创建新对象后实例数: {LifecycleDemo.instance_count}")  # 3

print("\n程序结束，剩余对象会自动销毁...")
# 程序结束时，obj1、obj3、obj4会被自动销毁，触发析构函数
```

---

## 7.5 封装

封装是 OOP 的核心概念之一，它隐藏对象的内部实现细节，只暴露必要的接口。

### 访问控制
Python 中没有严格的访问控制（如 private、protected），但通过命名约定来实现：
- **公有（Public）**：普通命名，如 `name`
- **保护（Protected）**：单下划线开头，如 `_name`（约定，实际上仍可访问）
- **私有（Private）**：双下划线开头，如 `__name`（会进行名称修饰）

```python
class BankAccount:
    """银行账户类（封装示例）"""
    
    def __init__(self, account_holder, initial_balance):
        # 公有属性
        self.account_holder = account_holder
        
        # 保护属性（单下划线开头，约定为内部使用）
        self._account_number = self._generate_account_number()
        
        # 私有属性（双下划线开头，会进行名称修饰）
        self.__balance = initial_balance
        self.__transaction_history = []
    
    def _generate_account_number(self):
        """保护方法 - 生成账户号"""
        import random
        return f"AC{random.randint(100000, 999999)}"
    
    def __validate_amount(self, amount):
        """私有方法 - 验证金额"""
        if amount <= 0:
            raise ValueError("金额必须大于0")
        return True
    
    # 公有方法 - 提供访问接口
    def deposit(self, amount):
        """存款"""
        try:
            self.__validate_amount(amount)
            self.__balance += amount
            self.__transaction_history.append(f"存入: +{amount}")
            print(f"成功存入 {amount} 元")
            return True
        except ValueError as e:
            print(f"存款失败: {e}")
            return False
    
    def withdraw(self, amount):
        """取款"""
        try:
            self.__validate_amount(amount)
            if amount > self.__balance:
                print(f"余额不足！当前余额: {self.__balance} 元")
                return False
            
            self.__balance -= amount
            self.__transaction_history.append(f"取出: -{amount}")
            print(f"成功取出 {amount} 元")
            return True
        except ValueError as e:
            print(f"取款失败: {e}")
            return False
    
    def get_balance(self):
        """获取余额（只读）"""
        return self.__balance
    
    def get_account_info(self):
        """获取账户信息"""
        return {
            "户主": self.account_holder,
            "账号": self._account_number,
            "余额": self.__balance,
            "交易次数": len(self.__transaction_history)
        }
    
    def get_transaction_history(self):
        """获取交易历史（只读副本）"""
        return self.__transaction_history.copy()  # 返回副本，防止外部修改

# 使用封装的类
account = BankAccount("张三", 10000)

# 访问公有属性
print(f"户主: {account.account_holder}")  # 张三

# 访问保护属性（不推荐，但可以）
print(f"账号: {account._account_number}")  # ACxxxxxx

# 直接访问私有属性会失败（名称已被修饰）
# print(account.__balance)  # AttributeError: 'BankAccount' object has no attribute '__balance'

# 查看实际的属性名
print(f"实际的属性名: {account.__dict__.keys()}")  
# dict_keys(['account_holder', '_account_number', '_BankAccount__balance', '_BankAccount__transaction_history'])

# 通过名称修饰仍然可以访问（但不应该这样做）
print(f"余额（不推荐的方式）: {account._BankAccount__balance}")  # 10000

# 正确的使用方式：通过公有方法访问
account.deposit(5000)    # 成功存入 5000 元
account.withdraw(3000)   # 成功取出 3000 元
# account.withdraw(20000)  # 余额不足！当前余额: 12000 元

print(f"当前余额: {account.get_balance()}")  # 12000
print(f"账户信息: {account.get_account_info()}")
print(f"交易历史: {account.get_transaction_history()}")
```

### 使用属性装饰器（@property）
属性装饰器提供更优雅的封装方式。

```python
class Person:
    """人类（使用@property封装）"""
    
    def __init__(self, name, age):
        self.name = name
        self._age = age  # 保护属性
        self._email = None
    
    @property
    def age(self):
        """获取年龄"""
        return self._age
    
    @age.setter
    def age(self, value):
        """设置年龄（带验证）"""
        if not isinstance(value, int):
            raise TypeError("年龄必须是整数")
        if value < 0 or value > 150:
            raise ValueError("年龄必须在0-150之间")
        self._age = value
    
    @age.deleter
    def age(self):
        """删除年龄"""
        print(f"正在删除 {self.name} 的年龄信息")
        self._age = None
    
    @property
    def email(self):
        """只读属性 - 邮箱"""
        if self._email is None:
            return f"{self.name.lower().replace(' ', '.')}@example.com"
        return self._email
    
    @property
    def is_adult(self):
        """计算属性 - 是否是成年人"""
        return self._age >= 18
    
    @property
    def birth_year(self):
        """计算属性 - 出生年份（假设当前是2024年）"""
        import datetime
        current_year = datetime.datetime.now().year
        return current_year - self._age
    
    def __str__(self):
        adult_status = "成年人" if self.is_adult else "未成年人"
        return f"{self.name}, {self._age}岁 ({adult_status}), 邮箱: {self.email}"

# 使用@property
person = Person("张三", 25)

# 获取属性（调用getter）
print(f"年龄: {person.age}")          # 25
print(f"邮箱: {person.email}")        # 张三@example.com（自动生成）
print(f"是否成年: {person.is_adult}")  # True
print(f"出生年份: {person.birth_year}")  # 1999（假设当前是2024年）

# 设置属性（调用setter）
person.age = 30  # 调用 @age.setter
print(f"新年龄: {person.age}")  # 30

# 尝试设置无效值
try:
    person.age = 200  # 触发验证
except ValueError as e:
    print(f"错误: {e}")  # 年龄必须在0-150之间

# 删除属性（调用deleter）
del person.age  # 正在删除 张三 的年龄信息
print(f"删除后年龄: {person.age}")  # None

# 只读属性（没有setter）
try:
    person.email = "new@email.com"  # AttributeError: can't set attribute
except AttributeError as e:
    print(f"错误: {e}")

# 实际应用：温度转换
class Temperature:
    """温度类"""
    
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """摄氏度"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:  # 绝对零度
            raise ValueError("温度不能低于绝对零度(-273.15°C)")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """华氏度（计算属性）"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        """通过华氏度设置摄氏度"""
        self._celsius = (value - 32) * 5/9
    
    @property
    def kelvin(self):
        """开尔文温度（计算属性）"""
        return self._celsius + 273.15
    
    @kelvin.setter
    def kelvin(self, value):
        """通过开尔文温度设置摄氏度"""
        if value < 0:
            raise ValueError("开尔文温度不能低于0")
        self._celsius = value - 273.15
    
    def __str__(self):
        return f"{self._celsius:.1f}°C = {self.fahrenheit:.1f}°F = {self.kelvin:.1f}K"

# 使用
temp = Temperature(25)
print(f"初始温度: {temp}")  # 25.0°C = 77.0°F = 298.1K

# 通过摄氏度设置
temp.celsius = 100
print(f"沸点: {temp}")  # 100.0°C = 212.0°F = 373.1K

# 通过华氏度设置
temp.fahrenheit = 32
print(f"冰点(华氏): {temp}")  # 0.0°C = 32.0°F = 273.1K

# 通过开尔文设置
temp.kelvin = 0
print(f"绝对零度: {temp}")  # -273.1°C = -459.7°F = 0.0K
```

---

## 7.6 继承

继承允许子类获取父类的属性和方法，实现代码复用。

### 7.6.1 单继承
```python
# 父类（基类）
class Animal:
    """动物类"""
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name} 在吃东西")
    
    def sleep(self):
        print(f"{self.name} 在睡觉")
    
    def make_sound(self):
        print(f"{self.name} 发出声音")
    
    def get_info(self):
        return f"{self.name}, {self.age}岁"

# 子类（派生类）
class Dog(Animal):
    """狗类 - 继承自动物类"""
    
    def __init__(self, name, age, breed):
        # 调用父类的构造函数
        super().__init__(name, age)
        # 添加子类特有的属性
        self.breed = breed
    
    # 重写父类方法
    def make_sound(self):
        print(f"{self.name} 在汪汪叫！")
    
    # 添加子类特有的方法
    def fetch(self, item):
        print(f"{self.name} 去捡 {item}")
    
    # 扩展父类方法
    def get_info(self):
        # 先获取父类的信息
        base_info = super().get_info()
        # 添加子类的信息
        return f"{base_info}, 品种: {self.breed}"

class Cat(Animal):
    """猫类 - 继承自动物类"""
    
    def __init__(self, name, age, color):
        super().__init__(name, age)
        self.color = color
    
    def make_sound(self):
        print(f"{self.name} 在喵喵叫！")
    
    def climb_tree(self):
        print(f"{self.name} 在爬树")
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, 颜色: {self.color}"

# 使用继承
print("=== 狗 ===")
dog = Dog("旺财", 3, "金毛")
dog.eat()           # 旺财 在吃东西（继承自Animal）
dog.make_sound()    # 旺财 在汪汪叫！（重写的方法）
dog.fetch("球")     # 旺财 去捡球（子类特有的方法）
print(dog.get_info())  # 旺财, 3岁, 品种: 金毛

print("\n=== 猫 ===")
cat = Cat("咪咪", 2, "白色")
cat.sleep()         # 咪咪 在睡觉（继承自Animal）
cat.make_sound()    # 咪咪 在喵喵叫！（重写的方法）
cat.climb_tree()    # 咪咪 在爬树（子类特有的方法）
print(cat.get_info())  # 咪咪, 2岁, 颜色: 白色

# 类型检查
print(f"\n类型检查:")
print(f"dog 是 Dog 的实例吗? {isinstance(dog, Dog)}")           # True
print(f"dog 是 Animal 的实例吗? {isinstance(dog, Animal)}")     # True
print(f"cat 是 Animal 的实例吗? {isinstance(cat, Animal)}")     # True
print(f"dog 是 Cat 的实例吗? {isinstance(dog, Cat)}")           # False

print(f"\n类关系:")
print(f"Dog 是 Animal 的子类吗? {issubclass(Dog, Animal)}")    # True
print(f"Animal 是 Dog 的子类吗? {issubclass(Animal, Dog)}")    # False
```

### 7.6.2 多继承
Python 支持多继承，一个类可以继承多个父类。

```python
# 多个父类
class Flyable:
    """可飞行的"""
    
    def __init__(self, max_altitude):
        self.max_altitude = max_altitude
        self.is_flying = False
    
    def take_off(self):
        if not self.is_flying:
            self.is_flying = True
            print("起飞！")
        else:
            print("已经在飞行中")
    
    def land(self):
        if self.is_flying:
            self.is_flying = False
            print("降落！")
        else:
            print("已经在地面")
    
    def fly(self):
        if self.is_flying:
            print(f"正在飞行，最大高度: {self.max_altitude}米")
        else:
            print("请先起飞")

class Swimmable:
    """可游泳的"""
    
    def __init__(self, max_depth):
        self.max_depth = max_depth
        self.is_swimming = False
    
    def dive(self):
        if not self.is_swimming:
            self.is_swimming = True
            print("潜水！")
        else:
            print("已经在游泳中")
    
    def surface(self):
        if self.is_swimming:
            self.is_swimming = False
            print("浮出水面！")
        else:
            print("已经在水面")
    
    def swim(self):
        if self.is_swimming:
            print(f"正在游泳，最大深度: {self.max_depth}米")
        else:
            print("请先潜水")

class Runnable:
    """可奔跑的"""
    
    def __init__(self, max_speed):
        self.max_speed = max_speed
        self.is_running = False
    
    def start_running(self):
        if not self.is_running:
            self.is_running = True
            print("开始奔跑！")
        else:
            print("已经在奔跑")
    
    def stop_running(self):
        if self.is_running:
            self.is_running = False
            print("停止奔跑")
        else:
            print("已经停止")
    
    def run(self):
        if self.is_running:
            print(f"正在奔跑，最大速度: {self.max_speed}km/h")
        else:
            print("请先开始奔跑")

# 多继承的子类
class Duck(Flyable, Swimmable, Runnable):
    """鸭子 - 可以飞、游泳、奔跑"""
    
    def __init__(self, name, max_altitude=100, max_depth=5, max_speed=10):
        # 分别调用各个父类的构造函数
        Flyable.__init__(self, max_altitude)
        Swimmable.__init__(self, max_depth)
        Runnable.__init__(self, max_speed)
        
        self.name = name
    
    def quack(self):
        print(f"{self.name} 在嘎嘎叫")
    
    def show_abilities(self):
        print(f"\n{self.name} 的能力:")
        print(f"  最大飞行高度: {self.max_altitude}米")
        print(f"  最大潜水深度: {self.max_depth}米")
        print(f"  最大奔跑速度: {self.max_speed}km/h")

# 使用多继承
duck = Duck("唐老鸭", max_altitude=50, max_depth=3, max_speed=8)

print("=== 鸭子的能力 ===")
duck.show_abilities()

print("\n=== 测试飞行能力 ===")
duck.take_off()  # 起飞！
duck.fly()       # 正在飞行，最大高度: 50米
duck.land()      # 降落！

print("\n=== 测试游泳能力 ===")
duck.dive()      # 潜水！
duck.swim()      # 正在游泳，最大深度: 3米
duck.surface()   # 浮出水面！

print("\n=== 测试奔跑能力 ===")
duck.start_running()  # 开始奔跑！
duck.run()            # 正在奔跑，最大速度: 8km/h
duck.stop_running()   # 停止奔跑

print("\n=== 鸭子特有的行为 ===")
duck.quack()  # 唐老鸭 在嘎嘎叫

# 方法解析顺序（MRO）
print(f"\n方法解析顺序(MRO):")
for i, cls in enumerate(Duck.__mro__):
    print(f"  {i}. {cls.__name__}")

# 实际应用：混合类（Mixin）
class JSONMixin:
    """JSON混合类 - 提供JSON序列化能力"""
    
    def to_json(self):
        """将对象转换为JSON字符串"""
        import json
        # 获取对象的字典表示
        data = self.__dict__.copy()
        # 过滤掉私有属性（以_开头）
        data = {k: v for k, v in data.items() if not k.startswith('_')}
        return json.dumps(data, ensure_ascii=False, indent=2)
    
    @classmethod
    def from_json(cls, json_str):
        """从JSON字符串创建对象"""
        import json
        data = json.loads(json_str)
        # 创建对象（假设构造函数接受所有键作为参数）
        return cls(**data)

class XMLMixin:
    """XML混合类 - 提供XML序列化能力"""
    
    def to_xml(self):
        """将对象转换为XML字符串"""
        from xml.etree.ElementTree import Element, tostring
        
        root = Element(self.__class__.__name__)
        for key, value in self.__dict__.items():
            if not key.startswith('_'):
                child = Element(key)
                child.text = str(value)
                root.append(child)
        
        return tostring(root, encoding='unicode')

class Product(JSONMixin, XMLMixin):
    """产品类 - 具有JSON和XML序列化能力"""
    
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category
    
    def __str__(self):
        return f"{self.name} - ¥{self.price} ({self.category})"

# 使用混合类
product = Product("笔记本电脑", 6999.99, "电子产品")

print("\n=== 产品信息 ===")
print(product)

print("\n=== JSON格式 ===")
print(product.to_json())

print("\n=== XML格式 ===")
print(product.to_xml())

# 从JSON创建对象
json_str = '{"name": "智能手机", "price": 3999.0, "category": "电子产品"}'
product2 = Product.from_json(json_str)
print(f"\n从JSON创建的对象: {product2}")
```

### 7.6.3 方法重写
子类可以重写父类的方法，提供不同的实现。

```python
class Shape:
    """形状基类"""
    
    def __init__(self, color):
        self.color = color
    
    def area(self):
        """计算面积（抽象方法）"""
        raise NotImplementedError("子类必须实现area方法")
    
    def perimeter(self):
        """计算周长（抽象方法）"""
        raise NotImplementedError("子类必须实现perimeter方法")
    
    def get_info(self):
        return f"形状: {self.__class__.__name__}, 颜色: {self.color}"

class Rectangle(Shape):
    """矩形类"""
    
    def __init__(self, color, width, height):
        super().__init__(color)
        self.width = width
        self.height = height
    
    # 重写（实现）父类的抽象方法
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    # 扩展父类方法
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, 宽: {self.width}, 高: {self.height}, 面积: {self.area()}, 周长: {self.perimeter()}"

class Circle(Shape):
    """圆形类"""
    
    def __init__(self, color, radius):
        super().__init__(color)
        self.radius = radius
    
    # 重写（实现）父类的抽象方法
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius
    
    # 重写get_info，但不调用super()
    def get_info(self):
        return f"圆形, 颜色: {self.color}, 半径: {self.radius}, 面积: {self.area():.2f}, 周长: {self.perimeter():.2f}"

class Square(Rectangle):
    """正方形类 - 继承自矩形"""
    
    def __init__(self, color, side):
        # 正方形的宽和高相等
        super().__init__(color, side, side)
        self.side = side
    
    # 正方形有更简单的面积计算方法（但继承的已经正确）
    # 可以重写get_info提供更合适的描述
    def get_info(self):
        return f"正方形, 颜色: {self.color}, 边长: {self.side}, 面积: {self.area()}, 周长: {self.perimeter()}"

# 使用方法重写
print("=== 各种形状 ===")

shapes = [
    Rectangle("红色", 5, 3),
    Circle("蓝色", 4),
    Square("绿色", 6)
]

for shape in shapes:
    print(shape.get_info())
    print(f"  面积: {shape.area():.2f}")
    print(f"  周长: {shape.perimeter():.2f}")
    print()

# 抽象基类的使用
from abc import ABC, abstractmethod

class Vehicle(ABC):
    """交通工具抽象基类"""
    
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
    
    @abstractmethod
    def start(self):
        """启动"""
        pass
    
    @abstractmethod
    def stop(self):
        """停止"""
        pass
    
    def get_info(self):
        return f"{self.brand} {self.model}"
    
    def __str__(self):
        return self.get_info()

class Car(Vehicle):
    """汽车类"""
    
    def __init__(self, brand, model, fuel_type):
        super().__init__(brand, model)
        self.fuel_type = fuel_type
        self.is_running = False
    
    def start(self):
        if not self.is_running:
            self.is_running = True
            print(f"{self.get_info()} 启动，燃料: {self.fuel_type}")
        else:
            print(f"{self.get_info()} 已经在运行")
    
    def stop(self):
        if self.is_running:
            self.is_running = False
            print(f"{self.get_info()} 停止")
        else:
            print(f"{self.get_info()} 已经停止")
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info} (燃料: {self.fuel_type})"

class ElectricCar(Car):
    """电动汽车类"""
    
    def __init__(self, brand, model, battery_capacity):
        super().__init__(brand, model, "电力")
        self.battery_capacity = battery_capacity
        self.battery_level = 100  # 百分比
    
    def start(self):
        if self.battery_level <= 0:
            print(f"{self.get_info()} 电池耗尽，无法启动")
            return
        
        super().start()
        print(f"  电池电量: {self.battery_level}%")
    
    def charge(self, amount):
        """充电"""
        self.battery_level = min(100, self.battery_level + amount)
        print(f"{self.get_info()} 充电至 {self.battery_level}%")
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, 电池容量: {self.battery_capacity}kWh"

# 使用抽象基类
print("\n=== 交通工具 ===")
car = Car("丰田", "凯美瑞", "汽油")
electric_car = ElectricCar("特斯拉", "Model 3", 75)

car.start()        # 丰田 凯美瑞 (燃料: 汽油) 启动，燃料: 汽油
car.stop()         # 丰田 凯美瑞 (燃料: 汽油) 停止

electric_car.start()  # 特斯拉 Model 3 (燃料: 电力), 电池容量: 75kWh 启动，燃料: 电力
                       #   电池电量: 100%
electric_car.charge(50)  # 特斯拉 Model 3 (燃料: 电力), 电池容量: 75kWh 充电至 100%

# 不能实例化抽象基类
try:
    vehicle = Vehicle("通用", "未知")  # TypeError: Can't instantiate abstract class Vehicle
except TypeError as e:
    print(f"\n错误: {e}")
```

---

## 7.7 多态

多态是指同一操作作用于不同的对象，可以有不同的解释和执行结果。

```python
# 多态示例
class Animal:
    """动物基类"""
    
    def speak(self):
        raise NotImplementedError("子类必须实现speak方法")

class Dog(Animal):
    def speak(self):
        return "汪汪！"

class Cat(Animal):
    def speak(self):
        return "喵喵！"

class Cow(Animal):
    def speak(self):
        return "哞哞！"

class Duck(Animal):
    def speak(self):
        return "嘎嘎！"

# 多态的使用
def animal_sounds(animals):
    """让一组动物发出声音"""
    for animal in animals:
        print(animal.speak())

# 创建不同类型的动物
animals = [Dog(), Cat(), Cow(), Duck()]

print("动物们的叫声:")
animal_sounds(animals)
# 输出:
# 汪汪！
# 喵喵！
# 哞哞！
# 嘎嘎！

# 更复杂的多态示例
class PaymentMethod:
    """支付方式基类"""
    
    def process_payment(self, amount):
        raise NotImplementedError("子类必须实现process_payment方法")
    
    def get_payment_info(self):
        raise NotImplementedError("子类必须实现get_payment_info方法")

class CreditCard(PaymentMethod):
    """信用卡支付"""
    
    def __init__(self, card_number, card_holder, expiry_date):
        self.card_number = card_number[-4:]  # 只存储最后4位
        self.card_holder = card_holder
        self.expiry_date = expiry_date
    
    def process_payment(self, amount):
        # 模拟信用卡支付处理
        print(f"处理信用卡支付: ¥{amount:.2f}")
        print(f"  卡号: **** **** **** {self.card_number}")
        print(f"  持卡人: {self.card_holder}")
        print(f"  有效期: {self.expiry_date}")
        return True
    
    def get_payment_info(self):
        return f"信用卡: **** **** **** {self.card_number}"

class PayPal(PaymentMethod):
    """PayPal支付"""
    
    def __init__(self, email):
        self.email = email
    
    def process_payment(self, amount):
        # 模拟PayPal支付处理
        print(f"处理PayPal支付: ¥{amount:.2f}")
        print(f"  PayPal账户: {self.email}")
        return True
    
    def get_payment_info(self):
        return f"PayPal: {self.email}"

class Alipay(PaymentMethod):
    """支付宝支付"""
    
    def __init__(self, account_id):
        self.account_id = account_id
    
    def process_payment(self, amount):
        # 模拟支付宝支付处理
        print(f"处理支付宝支付: ¥{amount:.2f}")
        print(f"  支付宝账户: {self.account_id}")
        # 模拟二维码生成
        print("  请扫描二维码完成支付")
        return True
    
    def get_payment_info(self):
        return f"支付宝: {self.account_id}"

# 购物车类
class ShoppingCart:
    """购物车"""
    
    def __init__(self):
        self.items = []
        self.total = 0.0
    
    def add_item(self, item_name, price):
        self.items.append((item_name, price))
        self.total += price
        print(f"添加商品: {item_name} - ¥{price:.2f}")
    
    def show_items(self):
        print("\n购物车商品:")
        for i, (item_name, price) in enumerate(self.items, 1):
            print(f"  {i}. {item_name}: ¥{price:.2f}")
        print(f"  总计: ¥{self.total:.2f}")
    
    def checkout(self, payment_method):
        """结账 - 使用多态处理不同的支付方式"""
        print("\n=== 结账 ===")
        self.show_items()
        print(f"支付方式: {payment_method.get_payment_info()}")
        
        # 多态：无论是什么支付方式，都调用相同的方法
        success = payment_method.process_payment(self.total)
        
        if success:
            print("支付成功！感谢您的购买。")
            self.items.clear()
            self.total = 0.0
        else:
            print("支付失败，请重试。")
        
        return success

# 使用多态
print("=== 在线购物示例 ===")

# 创建购物车
cart = ShoppingCart()
cart.add_item("Python编程书", 89.00)
cart.add_item("无线鼠标", 129.00)
cart.add_item("USB-C数据线", 39.00)

# 创建不同的支付方式
payment_methods = [
    CreditCard("1234 5678 9012 3456", "张三", "12/25"),
    PayPal("zhangsan@example.com"),
    Alipay("zhangsan_123")
]

# 使用不同的支付方式结账（多态）
for i, method in enumerate(payment_methods, 1):
    print(f"\n--- 尝试支付方式 {i} ---")
    cart.checkout(method)
    
    # 重新添加商品进行下一次测试
    if i < len(payment_methods):
        cart.add_item("测试商品", 100.00)

# 另一个多态示例：图形绘制
class Shape:
    """图形基类"""
    
    def draw(self):
        raise NotImplementedError("子类必须实现draw方法")
    
    def get_area(self):
        raise NotImplementedError("子类必须实现get_area方法")

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def draw(self):
        # 简单的ASCII艺术表示圆形
        print(f"绘制圆形 (半径: {self.radius})")
        print("   ***   ")
        print(" *     * ")
        print("*       *")
        print(" *     * ")
        print("   ***   ")
    
    def get_area(self):
        import math
        return math.pi * self.radius ** 2

class Square(Shape):
    def __init__(self, side):
        self.side = side
    
    def draw(self):
        print(f"绘制正方形 (边长: {self.side})")
        for i in range(self.side):
            print("  " + "* " * self.side)
    
    def get_area(self):
        return self.side ** 2

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def draw(self):
        print(f"绘制三角形 (底: {self.base}, 高: {self.height})")
        for i in range(1, self.height + 1):
            stars = "* " * (2 * i - 1)
            spaces = " " * (self.height - i)
            print(spaces + stars)
    
    def get_area(self):
        return 0.5 * self.base * self.height

# 图形绘制器 - 利用多态
class ShapeDrawer:
    """图形绘制器"""
    
    def __init__(self):
        self.shapes = []
    
    def add_shape(self, shape):
        self.shapes.append(shape)
    
    def draw_all(self):
        print("\n=== 绘制所有图形 ===")
        total_area = 0
        
        for i, shape in enumerate(self.shapes, 1):
            print(f"\n图形 {i}:")
            shape.draw()  # 多态：调用每个图形自己的draw方法
            area = shape.get_area()  # 多态：调用每个图形自己的get_area方法
            total_area += area
            print(f"  面积: {area:.2f}")
        
        print(f"\n所有图形的总面积: {total_area:.2f}")

# 使用多态绘制图形
drawer = ShapeDrawer()
drawer.add_shape(Circle(3))
drawer.add_shape(Square(4))
drawer.add_shape(Triangle(6, 4))

drawer.draw_all()
```

---

## 7.8 特殊方法（魔术方法）

特殊方法以双下划线开头和结尾，用于实现类的特殊行为。

```python
# 常用魔术方法示例
class Vector:
    """向量类 - 演示魔术方法的使用"""
    
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    
    # 1. 表示方法
    def __str__(self):
        """用户友好的字符串表示"""
        return f"Vector({self.x}, {self.y}, {self.z})"
    
    def __repr__(self):
        """官方的字符串表示，可用于重新创建对象"""
        return f"Vector({self.x}, {self.y}, {self.z})"
    
    # 2. 算术运算
    def __add__(self, other):
        """向量加法"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y, self.z + other.z)
        elif isinstance(other, (int, float)):
            return Vector(self.x + other, self.y + other, self.z + other)
        else:
            return NotImplemented
    
    def __sub__(self, other):
        """向量减法"""
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y, self.z - other.z)
        elif isinstance(other, (int, float)):
            return Vector(self.x - other, self.y - other, self.z - other)
        else:
            return NotImplemented
    
    def __mul__(self, other):
        """向量乘法（点积或标量乘法）"""
        if isinstance(other, (int, float)):
            # 标量乘法
            return Vector(self.x * other, self.y * other, self.z * other)
        elif isinstance(other, Vector):
            # 点积
            return self.x * other.x + self.y * other.y + self.z * other.z
        else:
            return NotImplemented
    
    def __truediv__(self, other):
        """向量除法（标量除法）"""
        if isinstance(other, (int, float)):
            if other == 0:
                raise ZeroDivisionError("不能除以零")
            return Vector(self.x / other, self.y / other, self.z / other)
        else:
            return NotImplemented
    
    # 3. 比较运算
    def __eq__(self, other):
        """相等比较"""
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y and self.z == other.z
        return False
    
    def __lt__(self, other):
        """小于比较（比较向量的模长）"""
        if isinstance(other, Vector):
            return self.magnitude() < other.magnitude()
        return NotImplemented
    
    # 4. 其他数学运算
    def __abs__(self):
        """绝对值（向量的模长）"""
        return self.magnitude()
    
    def __neg__(self):
        """取负"""
        return Vector(-self.x, -self.y, -self.z)
    
    # 5. 容器方法
    def __len__(self):
        """长度（向量维度）"""
        return 3
    
    def __getitem__(self, index):
        """索引访问"""
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        elif index == 2:
            return self.z
        else:
            raise IndexError("向量索引超出范围(0-2)")
    
    def __setitem__(self, index, value):
        """索引赋值"""
        if index == 0:
            self.x = value
        elif index == 1:
            self.y = value
        elif index == 2:
            self.z = value
        else:
            raise IndexError("向量索引超出范围(0-2)")
    
    def __iter__(self):
        """迭代"""
        return iter([self.x, self.y, self.z])
    
    # 6. 自定义方法
    def magnitude(self):
        """计算向量的模长"""
        return (self.x**2 + self.y**2 + self.z**2) ** 0.5
    
    def normalize(self):
        """单位化向量"""
        mag = self.magnitude()
        if mag == 0:
            raise ValueError("零向量不能单位化")
        return self / mag
    
    def cross(self, other):
        """叉积"""
        if not isinstance(other, Vector):
            raise TypeError("叉积需要另一个向量")
        
        x = self.y * other.z - self.z * other.y
        y = self.z * other.x - self.x * other.z
        z = self.x * other.y - self.y * other.x
        
        return Vector(x, y, z)

# 测试魔术方法
print("=== 向量类测试 ===")

# 创建向量
v1 = Vector(1, 2, 3)
v2 = Vector(4, 5, 6)

print(f"v1 = {v1}")        # Vector(1, 2, 3)
print(f"v2 = {v2}")        # Vector(4, 5, 6)

# 算术运算
print(f"\n算术运算:")
print(f"v1 + v2 = {v1 + v2}")           # Vector(5, 7, 9)
print(f"v1 - v2 = {v1 - v2}")           # Vector(-3, -3, -3)
print(f"v1 * 2 = {v1 * 2}")             # Vector(2, 4, 6)
print(f"v1 * v2 (点积) = {v1 * v2}")    # 32
print(f"v1 / 2 = {v1 / 2}")             # Vector(0.5, 1.0, 1.5)

# 比较运算
print(f"\n比较运算:")
print(f"v1 == v2? {v1 == v2}")          # False
print(f"v1 == Vector(1, 2, 3)? {v1 == Vector(1, 2, 3)}")  # True
print(f"v1 < v2? {v1 < v2}")            # True (比较模长)

# 其他运算
print(f"\n其他运算:")
print(f"-v1 = {-v1}")                    # Vector(-1, -2, -3)
print(f"|v1| = {abs(v1):.2f}")           # 3.74
print(f"v1的模长 = {v1.magnitude():.2f}") # 3.74

# 容器操作
print(f"\n容器操作:")
print(f"向量维度: {len(v1)}")            # 3
print(f"v1[0] = {v1[0]}")               # 1
print(f"v1[1] = {v1[1]}")               # 2
print(f"v1[2] = {v1[2]}")               # 3

# 迭代
print("向量元素:")
for component in v1:
    print(f"  {component}")

# 修改元素
v1[0] = 10
print(f"修改后 v1 = {v1}")               # Vector(10, 2, 3)

# 向量运算
print(f"\n向量运算:")
print(f"v1的单位向量: {v1.normalize()}")
print(f"v1 × v2 (叉积) = {v1.cross(v2)}")

# 完整示例：复数类
class ComplexNumber:
    """复数类"""
    
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    
    def __str__(self):
        if self.imag >= 0:
            return f"{self.real} + {self.imag}i"
        else:
            return f"{self.real} - {-self.imag}i"
    
    def __repr__(self):
        return f"ComplexNumber({self.real}, {self.imag})"
    
    def __add__(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real + other.real, self.imag + other.imag)
        elif isinstance(other, (int, float)):
            return ComplexNumber(self.real + other, self.imag)
        else:
            return NotImplemented
    
    def __sub__(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real - other.real, self.imag - other.imag)
        elif isinstance(other, (int, float)):
            return ComplexNumber(self.real - other, self.imag)
        else:
            return NotImplemented
    
    def __mul__(self, other):
        if isinstance(other, ComplexNumber):
            # (a+bi)(c+di) = (ac-bd) + (ad+bc)i
            real = self.real * other.real - self.imag * other.imag
            imag = self.real * other.imag + self.imag * other.real
            return ComplexNumber(real, imag)
        elif isinstance(other, (int, float)):
            return ComplexNumber(self.real * other, self.imag * other)
        else:
            return NotImplemented
    
    def __truediv__(self, other):
        if isinstance(other, ComplexNumber):
            # (a+bi)/(c+di) = [(a+bi)(c-di)] / (c²+d²)
            denominator = other.real**2 + other.imag**2
            if denominator == 0:
                raise ZeroDivisionError("复数除法分母不能为零")
            
            conjugate = ComplexNumber(other.real, -other.imag)
            numerator = self * conjugate
            return ComplexNumber(numerator.real / denominator, numerator.imag / denominator)
        elif isinstance(other, (int, float)):
            if other == 0:
                raise ZeroDivisionError("不能除以零")
            return ComplexNumber(self.real / other, self.imag / other)
        else:
            return NotImplemented
    
    def __abs__(self):
        """复数的模"""
        return (self.real**2 + self.imag**2) ** 0.5
    
    def __eq__(self, other):
        if isinstance(other, ComplexNumber):
            return self.real == other.real and self.imag == other.imag
        return False
    
    def conjugate(self):
        """共轭复数"""
        return ComplexNumber(self.real, -self.imag)
    
    @property
    def magnitude(self):
        """模长"""
        return abs(self)
    
    @property
    def phase(self):
        """相位（弧度）"""
        import math
        return math.atan2(self.imag, self.real)

# 测试复数类
print("\n=== 复数类测试 ===")

c1 = ComplexNumber(3, 4)
c2 = ComplexNumber(1, 2)

print(f"c1 = {c1}")          # 3 + 4i
print(f"c2 = {c2}")          # 1 + 2i
print(f"c1的模 = {abs(c1):.2f}")  # 5.00

print(f"\n复数运算:")
print(f"c1 + c2 = {c1 + c2}")      # 4 + 6i
print(f"c1 - c2 = {c1 - c2}")      # 2 + 2i
print(f"c1 × c2 = {c1 * c2}")      # -5 + 10i
print(f"c1 ÷ c2 = {c1 / c2}")      # 2.2 - 0.4i
print(f"c1的共轭 = {c1.conjugate()}")  # 3 - 4i

print(f"\n复数属性:")
print(f"c1的模长: {c1.magnitude:.2f}")  # 5.00
print(f"c1的相位: {c1.phase:.2f} 弧度")  # 0.93 弧度
```

---

## 7.9 抽象类和接口

抽象类是不能被实例化的类，用于定义接口和通用行为。

```python
from abc import ABC, abstractmethod

# 抽象类示例
class Employee(ABC):
    """员工抽象基类"""
    
    def __init__(self, name, employee_id):
        self.name = name
        self.employee_id = employee_id
        self.salary = 0
    
    @abstractmethod
    def calculate_salary(self):
        """计算工资（抽象方法）"""
        pass
    
    @abstractmethod
    def perform_duties(self):
        """履行职责（抽象方法）"""
        pass
    
    def get_info(self):
        """获取员工信息（具体方法）"""
        return f"员工: {self.name}, 工号: {self.employee_id}, 职位: {self.__class__.__name__}"

class FullTimeEmployee(Employee):
    """全职员工"""
    
    def __init__(self, name, employee_id, monthly_salary):
        super().__init__(name, employee_id)
        self.monthly_salary = monthly_salary
    
    def calculate_salary(self):
        """计算工资 - 月薪"""
        self.salary = self.monthly_salary
        return self.salary
    
    def perform_duties(self):
        return f"{self.name} 作为全职员工，每周工作40小时"

class PartTimeEmployee(Employee):
    """兼职员工"""
    
    def __init__(self, name, employee_id, hourly_rate, hours_worked):
        super().__init__(name, employee_id)
        self.hourly_rate = hourly_rate
        self.hours_worked = hours_worked
    
    def calculate_salary(self):
        """计算工资 - 时薪 × 工时"""
        self.salary = self.hourly_rate * self.hours_worked
        return self.salary
    
    def perform_duties(self):
        return f"{self.name} 作为兼职员工，本周工作了{self.hours_worked}小时"

class CommissionEmployee(Employee):
    """佣金员工"""
    
    def __init__(self, name, employee_id, base_salary, sales_amount, commission_rate):
        super().__init__(name, employee_id)
        self.base_salary = base_salary
        self.sales_amount = sales_amount
        self.commission_rate = commission_rate
    
    def calculate_salary(self):
        """计算工资 - 底薪 + 销售提成"""
        commission = self.sales_amount * self.commission_rate
        self.salary = self.base_salary + commission
        return self.salary
    
    def perform_duties(self):
        return f"{self.name} 作为销售员工，本月销售额为¥{self.sales_amount:.2f}"

# 使用抽象类
print("=== 员工管理系统 ===")

employees = [
    FullTimeEmployee("张三", "FT001", 15000),
    PartTimeEmployee("李四", "PT001", 50, 80),
    CommissionEmployee("王五", "CE001", 3000, 100000, 0.1)
]

# 处理各种员工（多态）
total_payroll = 0
for emp in employees:
    print(f"\n{emp.get_info()}")
    print(f"  职责: {emp.perform_duties()}")
    salary = emp.calculate_salary()
    print(f"  工资: ¥{salary:.2f}")
    total_payroll += salary

print(f"\n总工资支出: ¥{total_payroll:.2f}")

# 接口示例（Python中没有真正的接口，但可以用抽象类模拟）
class Drawable(ABC):
    """可绘制接口"""
    
    @abstractmethod
    def draw(self):
        pass
    
    @abstractmethod
    def get_area(self):
        pass

class Resizable(ABC):
    """可调整大小接口"""
    
    @abstractmethod
    def resize(self, factor):
        pass

class Movable(ABC):
    """可移动接口"""
    
    @abstractmethod
    def move(self, dx, dy):
        pass

# 实现多个接口
class Rectangle(Drawable, Resizable, Movable):
    """矩形 - 实现多个接口"""
    
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    
    # Drawable 接口实现
    def draw(self):
        print(f"在位置({self.x}, {self.y})绘制矩形，大小: {self.width}×{self.height}")
    
    def get_area(self):
        return self.width * self.height
    
    # Resizable 接口实现
    def resize(self, factor):
        self.width *= factor
        self.height *= factor
        print(f"矩形已缩放 {factor}倍，新大小: {self.width}×{self.height}")
    
    # Movable 接口实现
    def move(self, dx, dy):
        self.x += dx
        self.y += dy
        print(f"矩形已移动到 ({self.x}, {self.y})")
    
    def __str__(self):
        return f"矩形[位置: ({self.x}, {self.y}), 大小: {self.width}×{self.height}, 面积: {self.get_area()}]"

# 使用接口
print("\n=== 图形接口演示 ===")

rect = Rectangle(10, 20, 30, 40)
print(rect)

rect.draw()           # 调用 Drawable 接口方法
rect.move(5, -5)      # 调用 Movable 接口方法
rect.resize(1.5)      # 调用 Resizable 接口方法

print(f"\n移动和缩放后: {rect}")

# 类型检查
print(f"\n类型检查:")
print(f"rect 是 Drawable 的实例吗? {isinstance(rect, Drawable)}")      # True
print(f"rect 是 Resizable 的实例吗? {isinstance(rect, Resizable)}")    # True
print(f"rect 是 Movable 的实例吗? {isinstance(rect, Movable)}")        # True

# 实际应用：插件系统
class Plugin(ABC):
    """插件抽象基类"""
    
    @abstractmethod
    def initialize(self):
        """初始化插件"""
        pass
    
    @abstractmethod
    def execute(self, *args, **kwargs):
        """执行插件功能"""
        pass
    
    @abstractmethod
    def cleanup(self):
        """清理插件资源"""
        pass

class CalculatorPlugin(Plugin):
    """计算器插件"""
    
    def initialize(self):
        print("计算器插件已初始化")
    
    def execute(self, operation, *args):
        if operation == "add":
            return sum(args)
        elif operation == "multiply":
            result = 1
            for num in args:
                result *= num
            return result
        elif operation == "average":
            return sum(args) / len(args) if args else 0
        else:
            raise ValueError(f"不支持的操作: {operation}")
    
    def cleanup(self):
        print("计算器插件已清理")

class LoggerPlugin(Plugin):
    """日志插件"""
    
    def initialize(self):
        print("日志插件已初始化")
        self.logs = []
    
    def execute(self, message, level="INFO"):
        log_entry = f"[{level}] {message}"
        self.logs.append(log_entry)
        print(log_entry)
        return log_entry
    
    def cleanup(self):
        print(f"日志插件已清理，共记录 {len(self.logs)} 条日志")

# 插件管理器
class PluginManager:
    """插件管理器"""
    
    def __init__(self):
        self.plugins = []
    
    def register_plugin(self, plugin):
        if not isinstance(plugin, Plugin):
            raise TypeError("插件必须实现Plugin接口")
        
        self.plugins.append(plugin)
        plugin.initialize()
        print(f"已注册插件: {plugin.__class__.__name__}")
    
    def execute_all(self, *args, **kwargs):
        results = []
        for plugin in self.plugins:
            try:
                result = plugin.execute(*args, **kwargs)
                results.append((plugin.__class__.__name__, result))
            except Exception as e:
                print(f"插件 {plugin.__class__.__name__} 执行失败: {e}")
        return results
    
    def cleanup_all(self):
        for plugin in self.plugins:
            plugin.cleanup()
        self.plugins.clear()

# 使用插件系统
print("\n=== 插件系统演示 ===")

manager = PluginManager()

# 注册插件
manager.register_plugin(CalculatorPlugin())
manager.register_plugin(LoggerPlugin())

# 执行插件
print("\n执行插件:")
results = manager.execute_all("add", 1, 2, 3, 4, 5)
print(f"计算结果: {results}")

results = manager.execute_all("测试消息", level="DEBUG")
print(f"日志结果: {results}")

# 清理插件
print("\n清理插件:")
manager.cleanup_all()
```

---

## 7.10 综合示例

### 示例1：学生选课系统
```python
"""
学生选课系统 - 综合应用面向对象编程
"""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Dict, Optional

class Person(ABC):
    """人员抽象基类"""
    
    def __init__(self, id: str, name: str, email: str):
        self.id = id
        self.name = name
        self.email = email
        self.created_at = datetime.now()
    
    @abstractmethod
    def get_role(self) -> str:
        """获取角色"""
        pass
    
    def get_info(self) -> Dict:
        """获取信息"""
        return {
            "id": self.id,
            "name": self.name,
            "email": self.email,
            "role": self.get_role(),
            "created_at": self.created_at.strftime("%Y-%m-%d %H:%M:%S")
        }
    
    def __str__(self) -> str:
        return f"{self.name} ({self.id}) - {self.get_role()}"

class Course:
    """课程类"""
    
    def __init__(self, code: str, name: str, credits: int, max_students: int = 30):
        self.code = code
        self.name = name
        self.credits = credits
        self.max_students = max_students
        self.students: List[Student] = []
        self.instructor: Optional[Instructor] = None
    
    def add_student(self, student: 'Student') -> bool:
        """添加学生到课程"""
        if len(self.students) >= self.max_students:
            print(f"课程 {self.name} 已满，无法添加学生")
            return False
        
        if student in self.students:
            print(f"学生 {student.name} 已在此课程中")
            return False
        
        self.students.append(student)
        student.enroll_course(self)
        return True
    
    def remove_student(self, student: 'Student') -> bool:
        """从课程中移除学生"""
        if student in self.students:
            self.students.remove(student)
            student.drop_course(self)
            return True
        return False
    
    def assign_instructor(self, instructor: 'Instructor') -> bool:
        """分配教师"""
        self.instructor = instructor
        instructor.assign_course(self)
        return True
    
    def get_course_info(self) -> Dict:
        """获取课程信息"""
        return {
            "code": self.code,
            "name": self.name,
            "credits": self.credits,
            "max_students": self.max_students,
            "current_students": len(self.students),
            "instructor": self.instructor.name if self.instructor else "未分配",
            "student_list": [s.name for s in self.students]
        }
    
    def __str__(self) -> str:
        instructor_name = self.instructor.name if self.instructor else "未分配"
        return f"{self.code}: {self.name} ({self.credits}学分) - 教师: {instructor_name}, 学生: {len(self.students)}/{self.max_students}"

class Student(Person):
    """学生类"""
    
    def __init__(self, id: str, name: str, email: str, major: str):
        super().__init__(id, name, email)
        self.major = major
        self.enrolled_courses: List[Course] = []
        self.grades: Dict[str, float] = {}  # 课程代码 -> 成绩
    
    def get_role(self) -> str:
        return "学生"
    
    def enroll_course(self, course: Course) -> bool:
        """选课"""
        if course in self.enrolled_courses:
            print(f"已经选了课程 {course.name}")
            return False
        
        # 检查是否超过学分限制（假设最大20学分）
        current_credits = sum(c.credits for c in self.enrolled_courses)
        if current_credits + course.credits > 20:
            print(f"选课失败：已选{current_credits}学分，加上{course.credits}学分超过20学分限制")
            return False
        
        self.enrolled_courses.append(course)
        print(f"{self.name} 成功选了 {course.name}")
        return True
    
    def drop_course(self, course: Course) -> bool:
        """退课"""
        if course in self.enrolled_courses:
            self.enrolled_courses.remove(course)
            print(f"{self.name} 退了 {course.name}")
            return True
        return False
    
    def add_grade(self, course_code: str, grade: float) -> bool:
        """添加成绩"""
        if grade < 0 or grade > 100:
            print(f"成绩必须在0-100之间")
            return False
        
        self.grades[course_code] = grade
        return True
    
    def get_gpa(self) -> float:
        """计算GPA"""
        if not self.grades:
            return 0.0
        
        total_quality_points = 0
        total_credits = 0
        
        # 假设成绩转换规则：90-100: 4.0, 80-89: 3.0, 70-79: 2.0, 60-69: 1.0, <60: 0.0
        for course in self.enrolled_courses:
            if course.code in self.grades:
                grade = self.grades[course.code]
                
                # 计算绩点
                if grade >= 90:
                    quality_points = 4.0
                elif grade >= 80:
                    quality_points = 3.0
                elif grade >= 70:
                    quality_points = 2.0
                elif grade >= 60:
                    quality_points = 1.0
                else:
                    quality_points = 0.0
                
                total_quality_points += quality_points * course.credits
                total_credits += course.credits
        
        return total_quality_points / total_credits if total_credits > 0 else 0.0
    
    def get_student_info(self) -> Dict:
        """获取学生详细信息"""
        info = self.get_info()
        info.update({
            "major": self.major,
            "enrolled_courses": len(self.enrolled_courses),
            "total_credits": sum(c.credits for c in self.enrolled_courses),
            "gpa": f"{self.get_gpa():.2f}",
            "courses": [c.name for c in self.enrolled_courses]
        })
        return info
    
    def __str__(self) -> str:
        return f"学生: {self.name} ({self.id}) - {self.major}专业, GPA: {self.get_gpa():.2f}"

class Instructor(Person):
    """教师类"""
    
    def __init__(self, id: str, name: str, email: str, department: str):
        super().__init__(id, name, email)
        self.department = department
        self.assigned_courses: List[Course] = []
    
    def get_role(self) -> str:
        return "教师"
    
    def assign_course(self, course: Course) -> bool:
        """分配课程"""
        if course in self.assigned_courses:
            print(f"已经负责课程 {course.name}")
            return False
        
        self.assigned_courses.append(course)
        print(f"{self.name} 负责 {course.name}")
        return True
    
    def grade_student(self, student: Student, course_code: str, grade: float) -> bool:
        """给学生打分"""
        # 检查教师是否负责该课程
        course_taught = any(c.code == course_code for c in self.assigned_courses)
        if not course_taught:
            print(f"教师 {self.name} 不负责课程 {course_code}")
            return False
        
        return student.add_grade(course_code, grade)
    
    def get_instructor_info(self) -> Dict:
        """获取教师详细信息"""
        info = self.get_info()
        info.update({
            "department": self.department,
            "courses_taught": len(self.assigned_courses),
            "courses": [c.name for c in self.assigned_courses]
        })
        return info
    
    def __str__(self) -> str:
        return f"教师: {self.name} ({self.id}) - {self.department}系"

class CourseRegistrationSystem:
    """选课系统"""
    
    def __init__(self):
        self.students: Dict[str, Student] = {}
        self.instructors: Dict[str, Instructor] = {}
        self.courses: Dict[str, Course] = {}
    
    def add_student(self, student: Student) -> bool:
        """添加学生"""
        if student.id in self.students:
            print(f"学生 {student.id} 已存在")
            return False
        
        self.students[student.id] = student
        print(f"添加学生: {student.name}")
        return True
    
    def add_instructor(self, instructor: Instructor) -> bool:
        """添加教师"""
        if instructor.id in self.instructors:
            print(f"教师 {instructor.id} 已存在")
            return False
        
        self.instructors[instructor.id] = instructor
        print(f"添加教师: {instructor.name}")
        return True
    
    def add_course(self, course: Course) -> bool:
        """添加课程"""
        if course.code in self.courses:
            print(f"课程 {course.code} 已存在")
            return False
        
        self.courses[course.code] = course
        print(f"添加课程: {course.name}")
        return True
    
    def enroll_student_in_course(self, student_id: str, course_code: str) -> bool:
        """学生选课"""
        if student_id not in self.students:
            print(f"学生 {student_id} 不存在")
            return False
        
        if course_code not in self.courses:
            print(f"课程 {course_code} 不存在")
            return False
        
        student = self.students[student_id]
        course = self.courses[course_code]
        
        # 双向添加
        return course.add_student(student)
    
    def assign_instructor_to_course(self, instructor_id: str, course_code: str) -> bool:
        """分配教师到课程"""
        if instructor_id not in self.instructors:
            print(f"教师 {instructor_id} 不存在")
            return False
        
        if course_code not in self.courses:
            print(f"课程 {course_code} 不存在")
            return False
        
        instructor = self.instructors[instructor_id]
        course = self.courses[course_code]
        
        return course.assign_instructor(instructor)
    
    def grade_student(self, instructor_id: str, student_id: str, course_code: str, grade: float) -> bool:
        """教师给学生打分"""
        if instructor_id not in self.instructors:
            print(f"教师 {instructor_id} 不存在")
            return False
        
        if student_id not in self.students:
            print(f"学生 {student_id} 不存在")
            return False
        
        instructor = self.instructors[instructor_id]
        student = self.students[student_id]
        
        return instructor.grade_student(student, course_code, grade)
    
    def generate_report(self):
        """生成系统报告"""
        print("\n" + "="*60)
        print("选课系统报告")
        print("="*60)
        
        print(f"\n学生总数: {len(self.students)}")
        print(f"教师总数: {len(self.instructors)}")
        print(f"课程总数: {len(self.courses)}")
        
        print("\n课程详情:")
        for course_code, course in self.courses.items():
            print(f"  {course}")
        
        print("\n学生详情:")
        for student_id, student in self.students.items():
            print(f"  {student}")
        
        print("\n教师详情:")
        for instructor_id, instructor in self.instructors.items():
            print(f"  {instructor}")
        
        print("="*60)

# 使用选课系统
def main():
    """主函数"""
    print("=== 学生选课系统 ===")
    
    # 创建系统
    system = CourseRegistrationSystem()
    
    # 添加学生
    student1 = Student("S001", "张三", "zhangsan@example.com", "计算机科学")
    student2 = Student("S002", "李四", "lisi@example.com", "软件工程")
    student3 = Student("S003", "王五", "wangwu@example.com", "人工智能")
    
    system.add_student(student1)
    system.add_student(student2)
    system.add_student(student3)
    
    # 添加教师
    instructor1 = Instructor("T001", "张教授", "zhang@example.com", "计算机学院")
    instructor2 = Instructor("T002", "李教授", "li@example.com", "软件学院")
    
    system.add_instructor(instructor1)
    system.add_instructor(instructor2)
    
    # 添加课程
    course1 = Course("CS101", "Python编程", 3, 30)
    course2 = Course("CS201", "数据结构", 4, 25)
    course3 = Course("CS301", "算法设计", 4, 20)
    course4 = Course("SE101", "软件工程导论", 3, 30)
    
    system.add_course(course1)
    system.add_course(course2)
    system.add_course(course3)
    system.add_course(course4)
    
    # 分配教师
    system.assign_instructor_to_course("T001", "CS101")
    system.assign_instructor_to_course("T001", "CS201")
    system.assign_instructor_to_course("T002", "CS301")
    system.assign_instructor_to_course("T002", "SE101")
    
    # 学生选课
    print("\n=== 学生选课 ===")
    system.enroll_student_in_course("S001", "CS101")
    system.enroll_student_in_course("S001", "CS201")
    system.enroll_student_in_course("S001", "SE101")
    
    system.enroll_student_in_course("S002", "CS101")
    system.enroll_student_in_course("S002", "CS301")
    
    system.enroll_student_in_course("S003", "CS101")
    system.enroll_student_in_course("S003", "CS201")
    system.enroll_student_in_course("S003", "CS301")
    system.enroll_student_in_course("S003", "SE101")
    
    # 教师打分
    print("\n=== 教师打分 ===")
    system.grade_student("T001", "S001", "CS101", 95)
    system.grade_student("T001", "S001", "CS201", 88)
    system.grade_student("T002", "S001", "SE101", 92)
    
    system.grade_student("T001", "S002", "CS101", 78)
    system.grade_student("T002", "S002", "CS301", 85)
    
    system.grade_student("T001", "S003", "CS101", 90)
    system.grade_student("T001", "S003", "CS201", 82)
    system.grade_student("T002", "S003", "CS301", 88)
    system.grade_student("T002", "S003", "SE101", 95)
    
    # 生成报告
    system.generate_report()
    
    # 显示详细信息
    print("\n=== 学生详细信息 ===")
    for student_id, student in system.students.items():
        print(f"\n{student_id}:")
        for key, value in student.get_student_info().items():
            print(f"  {key}: {value}")

if __name__ == "__main__":
    main()
```

### 示例2：简单的电商系统
```python
"""
电商系统 - 商品、购物车、订单处理
"""

from datetime import datetime
from typing import List, Dict, Optional
import uuid

class Product:
    """商品类"""
    
    def __init__(self, name: str, price: float, description: str = "", 
                 category: str = "", stock: int = 0):
        self.id = str(uuid.uuid4())[:8]  # 生成简短ID
        self.name = name
        self.price = price
        self.description = description
        self.category = category
        self.stock = stock
        self.created_at = datetime.now()
    
    def reduce_stock(self, quantity: int) -> bool:
        """减少库存"""
        if quantity > self.stock:
            return False
        
        self.stock -= quantity
        return True
    
    def increase_stock(self, quantity: int):
        """增加库存"""
        self.stock += quantity
    
    def update_price(self, new_price: float):
        """更新价格"""
        if new_price >= 0:
            self.price = new_price
    
    def get_info(self) -> Dict:
        """获取商品信息"""
        return {
            "id": self.id,
            "name": self.name,
            "price": self.price,
            "description": self.description,
            "category": self.category,
            "stock": self.stock,
            "created_at": self.created_at.strftime("%Y-%m-%d %H:%M:%S")
        }
    
    def __str__(self) -> str:
        return f"{self.name} - ¥{self.price:.2f} (库存: {self.stock})"

class CartItem:
    """购物车项"""
    
    def __init__(self, product: Product, quantity: int = 1):
        self.product = product
        self.quantity = quantity
    
    def update_quantity(self, quantity: int) -> bool:
        """更新数量"""
        if quantity <= 0:
            return False
        
        self.quantity = quantity
        return True
    
    def get_total_price(self) -> float:
        """计算该项总价"""
        return self.product.price * self.quantity
    
    def __str__(self) -> str:
        return f"{self.product.name} × {self.quantity} = ¥{self.get_total_price():.2f}"

class ShoppingCart:
    """购物车"""
    
    def __init__(self):
        self.items: Dict[str, CartItem] = {}  # 商品ID -> CartItem
        self.created_at = datetime.now()
        self.updated_at = self.created_at
    
    def add_item(self, product: Product, quantity: int = 1) -> bool:
        """添加商品到购物车"""
        if product.id in self.items:
            # 如果已存在，增加数量
            current_item = self.items[product.id]
            new_quantity = current_item.quantity + quantity
            return current_item.update_quantity(new_quantity)
        else:
            # 创建新的购物车项
            if quantity > product.stock:
                print(f"库存不足，只有 {product.stock} 件")
                return False
            
            self.items[product.id] = CartItem(product, quantity)
            self.updated_at = datetime.now()
            return True
    
    def remove_item(self, product_id: str) -> bool:
        """从购物车移除商品"""
        if product_id in self.items:
            del self.items[product_id]
            self.updated_at = datetime.now()
            return True
        return False
    
    def update_quantity(self, product_id: str, quantity: int) -> bool:
        """更新商品数量"""
        if product_id in self.items:
            if quantity <= 0:
                return self.remove_item(product_id)
            
            item = self.items[product_id]
            if quantity > item.product.stock:
                print(f"库存不足，只有 {item.product.stock} 件")
                return False
            
            item.update_quantity(quantity)
            self.updated_at = datetime.now()
            return True
        return False
    
    def clear(self):
        """清空购物车"""
        self.items.clear()
        self.updated_at = datetime.now()
    
    def get_total(self) -> float:
        """计算购物车总价"""
        total = 0.0
        for item in self.items.values():
            total += item.get_total_price()
        return total
    
    def get_item_count(self) -> int:
        """获取商品总数"""
        count = 0
        for item in self.items.values():
            count += item.quantity
        return count
    
    def get_cart_info(self) -> Dict:
        """获取购物车信息"""
        items_info = []
        for item in self.items.values():
            items_info.append({
                "product_id": item.product.id,
                "product_name": item.product.name,
                "quantity": item.quantity,
                "unit_price": item.product.price,
                "total_price": item.get_total_price()
            })
        
        return {
            "item_count": self.get_item_count(),
            "total_price": self.get_total(),
            "items": items_info,
            "created_at": self.created_at.strftime("%Y-%m-%d %H:%M:%S"),
            "updated_at": self.updated_at.strftime("%Y-%m-%d %H:%M:%S")
        }
    
    def __str__(self) -> str:
        if not self.items:
            return "购物车为空"
        
        result = "购物车内容:\n"
        for item in self.items.values():
            result += f"  {item}\n"
        result += f"总计: ¥{self.get_total():.2f}"
        return result

class Order:
    """订单类"""
    
    def __init__(self, cart: ShoppingCart, customer_name: str, 
                 customer_address: str, customer_phone: str):
        self.order_id = str(uuid.uuid4())[:8]
        self.cart = cart
        self.customer_name = customer_name
        self.customer_address = customer_address
        self.customer_phone = customer_phone
        self.created_at = datetime.now()
        self.status = "待付款"  # 待付款、已付款、发货中、已发货、已完成、已取消
        self.payment_method = ""
        self.shipping_method = ""
        self.tracking_number = ""
    
    def process_payment(self, payment_method: str) -> bool:
        """处理付款"""
        if self.status != "待付款":
            print(f"订单状态为 {self.status}，无法付款")
            return False
        
        self.payment_method = payment_method
        self.status = "已付款"
        print(f"订单 {self.order_id} 付款成功，支付方式: {payment_method}")
        return True
    
    def process_shipping(self, shipping_method: str, tracking_number: str = "") -> bool:
        """处理发货"""
        if self.status != "已付款":
            print(f"订单状态为 {self.status}，无法发货")
            return False
        
        self.shipping_method = shipping_method
        self.tracking_number = tracking_number
        self.status = "已发货"
        print(f"订单 {self.order_id} 已发货，物流方式: {shipping_method}")
        return True
    
    def complete_order(self) -> bool:
        """完成订单"""
        if self.status != "已发货":
            print(f"订单状态为 {self.status}，无法完成")
            return False
        
        self.status = "已完成"
        print(f"订单 {self.order_id} 已完成")
        return True
    
    def cancel_order(self, reason: str = "") -> bool:
        """取消订单"""
        if self.status in ["已完成", "已发货"]:
            print(f"订单状态为 {self.status}，无法取消")
            return False
        
        self.status = "已取消"
        print(f"订单 {self.order_id} 已取消")
        if reason:
            print(f"原因: {reason}")
        return True
    
    def get_order_info(self) -> Dict:
        """获取订单信息"""
        cart_info = self.cart.get_cart_info()
        
        return {
            "order_id": self.order_id,
            "customer_name": self.customer_name,
            "customer_address": self.customer_address,
            "customer_phone": self.customer_phone,
            "status": self.status,
            "payment_method": self.payment_method,
            "shipping_method": self.shipping_method,
            "tracking_number": self.tracking_number,
            "total_amount": cart_info["total_price"],
            "item_count": cart_info["item_count"],
            "created_at": self.created_at.strftime("%Y-%m-%d %H:%M:%S"),
            "items": cart_info["items"]
        }
    
    def __str__(self) -> str:
        info = self.get_order_info()
        result = f"订单号: {info['order_id']}\n"
        result += f"客户: {info['customer_name']}\n"
        result += f"状态: {info['status']}\n"
        result += f"总金额: ¥{info['total_amount']:.2f}\n"
        result += f"创建时间: {info['created_at']}"
        return result

class ECommerceSystem:
    """电商系统"""
    
    def __init__(self):
        self.products: Dict[str, Product] = {}
        self.orders: Dict[str, Order] = {}
        self.carts: Dict[str, ShoppingCart] = {}  # 用户ID -> 购物车
    
    def add_product(self, product: Product) -> bool:
        """添加商品"""
        if product.id in self.products:
            print(f"商品 {product.id} 已存在")
            return False
        
        self.products[product.id] = product
        print(f"添加商品: {product.name}")
        return True
    
    def get_product(self, product_id: str) -> Optional[Product]:
        """获取商品"""
        return self.products.get(product_id)
    
    def search_products(self, keyword: str = "", category: str = "") -> List[Product]:
        """搜索商品"""
        results = []
        for product in self.products.values():
            match_keyword = not keyword or keyword.lower() in product.name.lower() or keyword.lower() in product.description.lower()
            match_category = not category or category.lower() == product.category.lower()
            
            if match_keyword and match_category:
                results.append(product)
        
        return results
    
    def get_or_create_cart(self, user_id: str) -> ShoppingCart:
        """获取或创建购物车"""
        if user_id not in self.carts:
            self.carts[user_id] = ShoppingCart()
        
        return self.carts[user_id]
    
    def checkout(self, user_id: str, customer_name: str, 
                 customer_address: str, customer_phone: str) -> Optional[Order]:
        """结账"""
        if user_id not in self.carts:
            print(f"用户 {user_id} 没有购物车")
            return None
        
        cart = self.carts[user_id]
        
        if cart.get_item_count() == 0:
            print("购物车为空，无法结账")
            return None
        
        # 检查库存
        for item in cart.items.values():
            if item.quantity > item.product.stock:
                print(f"商品 {item.product.name} 库存不足，只有 {item.product.stock} 件")
                return None
        
        # 扣减库存
        for item in cart.items.values():
            item.product.reduce_stock(item.quantity)
        
        # 创建订单
        order = Order(cart, customer_name, customer_address, customer_phone)
        self.orders[order.order_id] = order
        
        # 清空购物车
        cart.clear()
        
        print(f"订单创建成功: {order.order_id}")
        return order
    
    def process_order_payment(self, order_id: str, payment_method: str) -> bool:
        """处理订单付款"""
        if order_id not in self.orders:
            print(f"订单 {order_id} 不存在")
            return False
        
        order = self.orders[order_id]
        return order.process_payment(payment_method)
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单"""
        return self.orders.get(order_id)
    
    def generate_sales_report(self):
        """生成销售报告"""
        print("\n" + "="*60)
        print("电商系统销售报告")
        print("="*60)
        
        print(f"\n商品总数: {len(self.products)}")
        print(f"订单总数: {len(self.orders)}")
        
        # 统计各状态订单
        status_count = {}
        for order in self.orders.values():
            status = order.status
            status_count[status] = status_count.get(status, 0) + 1
        
        print("\n订单状态统计:")
        for status, count in status_count.items():
            print(f"  {status}: {count}")
        
        # 计算总销售额
        total_sales = 0.0
        completed_sales = 0.0
        
        for order in self.orders.values():
            total = order.cart.get_total()
            total_sales += total
            if order.status == "已完成":
                completed_sales += total
        
        print(f"\n总销售额: ¥{total_sales:.2f}")
        print(f"已完成订单销售额: ¥{completed_sales:.2f}")
        
        # 热门商品
        print("\n热门商品:")
        product_sales = {}
        for order in self.orders.values():
            for item in order.cart.items.values():
                product_id = item.product.id
                product_sales[product_id] = product_sales.get(product_id, 0) + item.quantity
        
        # 按销量排序
        sorted_products = sorted(product_sales.items(), key=lambda x: x[1], reverse=True)
        
        for product_id, quantity in sorted_products[:5]:  # 显示前5个
            product = self.products.get(product_id)
            if product:
                print(f"  {product.name}: 销量 {quantity}")
        
        print("="*60)

# 使用电商系统
def main():
    """主函数"""
    print("=== 电商系统 ===")
    
    # 创建系统
    system = ECommerceSystem()
    
    # 添加商品
    products = [
        Product("iPhone 15", 7999.0, "最新款iPhone", "手机", 100),
        Product("MacBook Pro", 12999.0, "苹果笔记本电脑", "电脑", 50),
        Product("AirPods Pro", 1999.0, "降噪无线耳机", "耳机", 200),
        Product("iPad Air", 4799.0, "平板电脑", "平板", 80),
        Product("Apple Watch", 2999.0, "智能手表", "手表", 150)
    ]
    
    for product in products:
        system.add_product(product)
    
    # 用户1购物
    print("\n=== 用户1购物 ===")
    user1_id = "user_001"
    cart1 = system.get_or_create_cart(user1_id)
    
    cart1.add_item(products[0], 1)  # iPhone 15
    cart1.add_item(products[2], 2)  # AirPods Pro × 2
    
    print(cart1)
    
    # 用户2购物
    print("\n=== 用户2购物 ===")
    user2_id = "user_002"
    cart2 = system.get_or_create_cart(user2_id)
    
    cart2.add_item(products[1], 1)  # MacBook Pro
    cart2.add_item(products[3], 1)  # iPad Air
    cart2.add_item(products[4], 1)  # Apple Watch
    
    print(cart2)
    
    # 结账
    print("\n=== 结账 ===")
    order1 = system.checkout(
        user1_id, 
        "张三", 
        "北京市海淀区", 
        "13800138000"
    )
    
    order2 = system.checkout(
        user2_id,
        "李四",
        "上海市浦东新区",
        "13900139000"
    )
    
    # 处理订单
    if order1:
        order1.process_payment("支付宝")
        order1.process_shipping("顺丰快递", "SF1234567890")
    
    if order2:
        order2.process_payment("微信支付")
    
    # 显示订单信息
    print("\n=== 订单信息 ===")
    for order_id, order in system.orders.items():
        print(f"\n{order}")
    
    # 生成报告
    system.generate_sales_report()
    
    # 搜索商品
    print("\n=== 商品搜索 ===")
    search_results = system.search_products(keyword="苹果", category="")
    print(f"搜索到 {len(search_results)} 个商品:")
    for product in search_results:
        print(f"  {product}")

if __name__ == "__main__":
    main()
```

---

## 7.11 本章练习

### 练习1：类和对象基础
1. 创建一个 `Student` 类，包含属性：姓名、学号、年龄、成绩列表。添加方法：
   - `add_grade(grade)`: 添加成绩
   - `get_average()`: 计算平均成绩
   - `get_highest_grade()`: 获取最高成绩
   - `__str__()`: 返回学生信息的字符串表示

2. 创建一个 `Rectangle` 类，包含属性：长度、宽度。添加方法：
   - `area()`: 计算面积
   - `perimeter()`: 计算周长
   - `is_square()`: 判断是否是正方形
   - 使用 `@property` 装饰器创建只读属性 `diagonal`（对角线长度）

### 练习2：继承和多态
1. 创建 `Vehicle` 基类，包含属性：品牌、型号、年份。添加方法：`start()`, `stop()`, `get_info()`。
2. 创建 `Car` 和 `Motorcycle` 子类，重写 `start()` 和 `stop()` 方法。
3. 创建 `ElectricCar` 子类，继承自 `Car`，添加属性：电池容量、续航里程。
4. 创建一个函数，接受 `Vehicle` 列表，调用每个车辆的 `start()` 方法（多态）。

### 练习3：封装和属性装饰器
1. 创建一个 `BankAccount` 类，使用封装：
   - 私有属性：`__balance`（余额）
   - 公有方法：`deposit(amount)`, `withdraw(amount)`, `get_balance()`
   - 添加验证：存款和取款金额必须为正数，取款不能超过余额

2. 创建一个 `Temperature` 类，使用 `@property`：
   - 私有属性：`_celsius`（摄氏度）
   - 属性：`celsius`, `fahrenheit`, `kelvin`（互相转换）
   - 添加验证：温度不能低于绝对零度

### 练习4：特殊方法
1. 创建一个 `Fraction`（分数）类，实现以下特殊方法：
   - `__init__(self, numerator, denominator)`
   - `__str__(self)` 和 `__repr__(self)`
   - `__add__(self, other)`, `__sub__(self, other)`, `__mul__(self, other)`, `__truediv__(self, other)`
   - `__eq__(self, other)`, `__lt__(self, other)`, `__gt__(self, other)`
   - `__float__(self)`: 转换为浮点数

2. 创建一个 `Vector3D` 类，表示三维向量，实现向量运算的特殊方法。

### 练习5：抽象类和接口
1. 创建 `Shape` 抽象类，包含抽象方法：`area()`, `perimeter()`, `draw()`。
2. 创建 `Circle`, `Rectangle`, `Triangle` 子类，实现抽象方法。
3. 创建 `Drawable` 和 `Resizable` 接口（用抽象类模拟），让 `Shape` 子类实现这些接口。

### 练习6：综合项目
创建一个**图书馆管理系统**，包含以下类：

1. **Book类**：
   - 属性：ISBN、书名、作者、出版年份、是否可借
   - 方法：借出、归还、获取信息

2. **Member类**：
   - 属性：会员ID、姓名、联系方式、已借书籍列表
   - 方法：借书、还书、查看已借书籍、获取会员信息

3. **Library类**：
   - 属性：书籍列表、会员列表
   - 方法：添加书籍、删除书籍、添加会员、删除会员、查找书籍、借书处理、还书处理、生成报告

4. **LoanRecord类**：
   - 属性：借书记录ID、书籍、会员、借出日期、应还日期、实际归还日期
   - 方法：计算逾期天数、计算罚款

要求：
- 使用继承、封装、多态
- 使用异常处理（如图书不存在、会员不存在、图书已借出等）
- 使用魔术方法（如 `__str__`, `__repr__`）
- 实现简单的持久化（保存到文件）

### 练习7：代码调试
找出以下代码中的问题并修正：

```python
# 问题代码1
class Person:
    def __init__(name, age):
        name = name
        age = age
    
    def get_info():
        return f"{name}, {age}岁"

p = Person("张三", 25)
print(p.get_info())

# 问题代码2
class Calculator:
    def add(self, a, b):
        result = a + b
    
    def show_result(self):
        print(f"结果: {result}")

calc = Calculator()
calc.add(5, 3)
calc.show_result()
```

---

## 总结

本章中，你学习了：
- ✅ **面向对象编程基础**：类、对象、实例化
- ✅ **类的属性和方法**：实例属性/方法、类属性/方法、静态方法
- ✅ **构造函数和析构函数**：`__init__()` 和 `__del__()`
- ✅ **封装**：访问控制、属性装饰器 `@property`
- ✅ **继承**：单继承、多继承、方法重写、`super()` 函数
- ✅ **多态**：同一接口的不同实现
- ✅ **特殊方法**：魔术方法实现类的特殊行为
- ✅ **抽象类和接口**：定义规范，强制子类实现

**关键要点**：
1. 类是对象的蓝图，对象是类的实例
2. 封装隐藏实现细节，暴露必要接口
3. 继承实现代码复用，多态提高灵活性
4. 特殊方法让类可以像内置类型一样工作
5. 抽象类和接口定义规范，确保一致性

**编程建议**：
- 遵循单一职责原则：一个类只做一件事
- 优先使用组合而不是继承
- 使用 `@property` 装饰器实现更优雅的属性访问
- 合理使用抽象类和接口定义规范
- 为类和方法添加文档字符串
- 使用类型注解提高代码可读性

---

## 扩展知识
- [Python 面向对象编程官方文档](https://docs.python.org/zh-cn/3/tutorial/classes.html)
- [Python 数据模型（特殊方法）](https://docs.python.org/zh-cn/3/reference/datamodel.html)
- [Python abc 模块（抽象基类）](https://docs.python.org/zh-cn/3/library/abc.html)
- [面向对象设计原则](https://en.wikipedia.org/wiki/SOLID)

---
**下一章**：[第8章：错误和异常处理]

> 如果有任何问题，欢迎在 [Issues](https://github.com/SuperF2023/python-basics-tutorial/issues) 中提问！