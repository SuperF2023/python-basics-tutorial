# 第5章：函数

## 目录
- [5.1 什么是函数？](#51-什么是函数)
- [5.2 定义和调用函数](#52-定义和调用函数)
- [5.3 函数参数](#53-函数参数)
  - [5.3.1 位置参数](#531-位置参数)
  - [5.3.2 关键字参数](#532-关键字参数)
  - [5.3.3 默认参数](#533-默认参数)
  - [5.3.4 可变参数](#534-可变参数)
  - [5.3.5 参数组合](#535-参数组合)
- [5.4 返回值](#54-返回值)
- [5.5 变量作用域](#55-变量作用域)
- [5.6 函数的高级特性](#56-函数的高级特性)
  - [5.6.1 匿名函数（Lambda）](#561-匿名函数lambda)
  - [5.6.2 高阶函数](#562-高阶函数)
  - [5.6.3 闭包](#563-闭包)
  - [5.6.4 装饰器](#564-装饰器)
- [5.7 递归函数](#57-递归函数)
- [5.8 内置函数介绍](#58-内置函数介绍)
- [5.9 综合示例](#59-综合示例)
- [5.10 本章练习](#510-本章练习)

---

## 5.1 什么是函数？

### 函数的概念
**函数**是一段可以重复使用的代码块，用于完成特定任务。你可以把函数想象成一个"黑盒子"：
- **输入**：接收参数
- **处理**：执行特定操作
- **输出**：返回结果

### 为什么需要函数？
1. **代码复用**：避免重复编写相同代码
2. **模块化**：将复杂问题分解为小问题
3. **可读性**：通过有意义的函数名提高代码可读性
4. **维护性**：修改只需在一个地方进行
5. **测试性**：可以单独测试每个函数

```python
# 不使用函数的重复代码
print("欢迎来到Python世界！")
print("=" * 30)
print("今天是学习的第一天")
print("=" * 30)

print("欢迎来到Python世界！")
print("=" * 30)
print("今天是学习的第二天")
print("=" * 30)

# 使用函数避免重复
def print_section(title, content):
    """打印一个带标题和内容的部分"""
    print("欢迎来到Python世界！")
    print("=" * 30)
    print(f"{title}: {content}")
    print("=" * 30)

# 调用函数
print_section("今天的学习", "第一天")
print_section("今天的学习", "第二天")
```

### 函数的分类
1. **内置函数**：Python自带的函数，如 `print()`, `len()`, `input()`
2. **自定义函数**：用户自己定义的函数
3. **库函数**：从模块导入的函数

```python
# 内置函数示例
text = "Hello, Python!"
print(f"长度: {len(text)}")  # len()是内置函数
print(f"大写: {text.upper()}")  # upper()是字符串方法

# 自定义函数
def greet(name):
    return f"Hello, {name}!"

# 库函数
import math
print(f"π的值: {math.pi}")
print(f"平方根: {math.sqrt(16)}")
```

---

## 5.2 定义和调用函数

### 定义函数的基本语法
```python
def function_name(parameters):
    """文档字符串（可选）"""
    # 函数体
    # 执行操作
    return value  # 返回值（可选）
```

### 简单函数示例
```python
# 示例1：无参数、无返回值
def say_hello():
    """打印问候语"""
    print("Hello, World!")
    print("欢迎学习Python函数")

# 调用函数
say_hello()
say_hello()  # 可以多次调用

# 示例2：带参数
def greet_person(name):
    """向指定的人问好"""
    print(f"你好，{name}！")
    print(f"很高兴认识你，{name}！")

# 调用带参数的函数
greet_person("Alice")
greet_person("Bob")

# 示例3：有返回值
def add_numbers(a, b):
    """计算两个数的和"""
    result = a + b
    return result

# 调用并接收返回值
sum_result = add_numbers(5, 3)
print(f"5 + 3 = {sum_result}")

# 直接使用返回值
print(f"10 + 20 = {add_numbers(10, 20)}")
```

### 函数的文档字符串（Docstring）
良好的函数应该包含文档字符串，说明函数的功能、参数和返回值。

```python
def calculate_circle_area(radius):
    """
    计算圆的面积
    
    参数:
    radius (float): 圆的半径，必须为正数
    
    返回:
    float: 圆的面积
    
    示例:
    >>> calculate_circle_area(5)
    78.53981633974483
    """
    import math
    return math.pi * radius ** 2

# 查看文档字符串
print(calculate_circle_area.__doc__)

# 使用help()函数查看
help(calculate_circle_area)

# 调用函数
area = calculate_circle_area(5)
print(f"半径为5的圆面积: {area:.2f}")
```

### 空函数（占位符）
```python
# 有时我们需要先定义函数结构，稍后实现
def function_to_be_implemented():
    """这个函数稍后实现"""
    pass  # pass语句什么都不做，只是占位符

def another_function():
    """TODO: 实现这个函数"""
    # 暂时留空，但会引发IndentationError
    # 所以需要pass或...
    ...

# 实际使用：在开发过程中先定义接口
def process_data(data):
    """处理数据（稍后实现）"""
    # TODO: 添加数据处理逻辑
    pass

def generate_report():
    """生成报告（稍后实现）"""
    # TODO: 实现报告生成
    pass
```

---

## 5.3 函数参数

### 5.3.1 位置参数
位置参数是最常见的参数类型，按照定义时的顺序传递。

```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"\n我有一只{animal_type}。")
    print(f"我的{animal_type}叫{pet_name}。")

# 按位置传递参数
describe_pet("狗", "旺财")
describe_pet("猫", "咪咪")

# 位置很重要！
describe_pet("旺财", "狗")  # 错误：顺序不对
```

### 5.3.2 关键字参数
通过参数名指定值，可以不按顺序传递参数。

```python
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print(f"\n我有一只{animal_type}。")
    print(f"我的{animal_type}叫{pet_name}。")

# 使用关键字参数
describe_pet(animal_type="狗", pet_name="旺财")
describe_pet(pet_name="咪咪", animal_type="猫")  # 顺序可以改变

# 混合使用位置参数和关键字参数
describe_pet("狗", pet_name="旺财")  # 位置参数必须在关键字参数之前
# describe_pet(pet_name="旺财", "狗")  # 错误：位置参数在关键字参数之后
```

### 5.3.3 默认参数
定义函数时给参数指定默认值，调用时可以不传递该参数。

```python
def describe_pet(pet_name, animal_type="狗"):
    """显示宠物的信息（animal_type有默认值）"""
    print(f"\n我有一只{animal_type}。")
    print(f"我的{animal_type}叫{pet_name}。")

# 使用默认值
describe_pet("旺财")  # 不提供animal_type，使用默认值"狗"
describe_pet("咪咪", "猫")  # 提供animal_type，覆盖默认值
describe_pet("小白", animal_type="兔子")  # 使用关键字参数

# 默认参数的实际应用
def make_shirt(size="L", message="我喜欢Python"):
    """制作T恤"""
    print(f"\n制作一件{size}号的T恤。")
    print(f"T恤上印着: '{message}'")

make_shirt()  # 使用所有默认值
make_shirt("M")  # 只指定size，message使用默认值
make_shirt(message="Hello World")  # 只指定message，size使用默认值
make_shirt("S", "编程改变世界")  # 指定所有参数

# 注意事项：默认参数在函数定义时计算一次
def add_item(item, item_list=[]):
    """向列表添加项目（有问题的默认参数）"""
    item_list.append(item)
    return item_list

# 问题：多次调用会共享同一个默认列表
print(add_item("苹果"))  # ['苹果']
print(add_item("香蕉"))  # ['苹果', '香蕉'] - 不是预期的['香蕉']

# 正确做法：使用None作为默认值
def add_item_correct(item, item_list=None):
    """向列表添加项目（正确的默认参数用法）"""
    if item_list is None:
        item_list = []
    item_list.append(item)
    return item_list

print(add_item_correct("苹果"))  # ['苹果']
print(add_item_correct("香蕉"))  # ['香蕉'] - 正确
```

### 5.3.4 可变参数
#### *args：接收任意数量的位置参数
```python
def make_pizza(*toppings):
    """制作披萨，接受任意数量的配料"""
    print("\n制作披萨，配料如下:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza("蘑菇")
make_pizza("蘑菇", "青椒", "洋葱", "香肠")

# args是一个元组
def sum_numbers(*args):
    """计算任意数量数字的和"""
    print(f"参数类型: {type(args)}")  # <class 'tuple'>
    print(f"参数: {args}")
    return sum(args)

print(f"和: {sum_numbers(1, 2, 3)}")
print(f"和: {sum_numbers(1, 2, 3, 4, 5)}")

# 混合使用位置参数和*args
def make_pizza(size, *toppings):
    """制作指定大小和配料的披萨"""
    print(f"\n制作一个{size}寸披萨，配料如下:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza(12, "蘑菇", "青椒")
make_pizza(9, "香肠")  # 9是size，不是配料
```

#### **kwargs：接收任意数量的关键字参数
```python
def build_profile(**kwargs):
    """创建用户个人资料"""
    print("\n用户个人资料:")
    for key, value in kwargs.items():
        print(f"{key}: {value}")

build_profile(name="Alice", age=25, city="北京")
build_profile(name="Bob", age=30, city="上海", hobby="编程", job="工程师")

# kwargs是一个字典
def print_info(**kwargs):
    """打印关键字参数"""
    print(f"参数类型: {type(kwargs)}")  # <class 'dict'>
    print(f"参数: {kwargs}")

print_info(name="Alice", score=95)

# 实际应用：配置函数
def configure_app(**options):
    """配置应用程序"""
    defaults = {
        "host": "localhost",
        "port": 8080,
        "debug": False,
        "timeout": 30
    }
    
    # 使用默认值，但允许用户覆盖
    config = defaults.copy()
    config.update(options)
    
    return config

# 使用
app_config = configure_app(port=9000, debug=True)
print(f"应用配置: {app_config}")
```

### 5.3.5 参数组合
参数定义的顺序必须是：位置参数、默认参数、*args、**kwargs。

```python
def function(a, b, c=10, *args, **kwargs):
    """
    参数组合示例
    
    参数:
    a, b: 位置参数（必须提供）
    c: 默认参数（可选）
    *args: 可变位置参数
    **kwargs: 可变关键字参数
    """
    print(f"a={a}, b={b}, c={c}")
    print(f"args={args}")
    print(f"kwargs={kwargs}")
    print("-" * 30)

# 测试各种调用方式
function(1, 2)  # a=1, b=2, c=10, args=(), kwargs={}
function(1, 2, 3)  # a=1, b=2, c=3, args=(), kwargs={}
function(1, 2, 3, 4, 5)  # a=1, b=2, c=3, args=(4, 5), kwargs={}
function(1, 2, 3, 4, 5, x=6, y=7)  # a=1, b=2, c=3, args=(4, 5), kwargs={'x':6, 'y':7}
function(1, 2, x=6, y=7)  # a=1, b=2, c=10, args=(), kwargs={'x':6, 'y':7}

# 实际示例：学生信息收集
def register_student(name, age, *courses, **additional_info):
    """注册学生信息"""
    print(f"\n学生注册信息:")
    print(f"姓名: {name}")
    print(f"年龄: {age}")
    
    if courses:
        print("选修课程:")
        for course in courses:
            print(f"  - {course}")
    
    if additional_info:
        print("附加信息:")
        for key, value in additional_info.items():
            print(f"  {key}: {value}")

# 注册学生
register_student("张三", 20, "数学", "物理", "化学")
register_student("李四", 22, "英语", "历史", 
                 email="lisi@example.com", phone="13800138000")
register_student("王五", 21, address="北京市", hobby="篮球")
```

### 参数解包
```python
# 使用 * 解包列表/元组，** 解包字典
def print_student_info(name, age, score):
    """打印学生信息"""
    print(f"姓名: {name}, 年龄: {age}, 成绩: {score}")

# 传统方式
print_student_info("Alice", 20, 95)

# 使用解包
student_data = ("Bob", 21, 88)
print_student_info(*student_data)  # 解包元组

student_dict = {"name": "Charlie", "age": 22, "score": 92}
print_student_info(**student_dict)  # 解包字典

# 混合解包
def complex_function(a, b, c, d, e):
    print(f"a={a}, b={b}, c={c}, d={d}, e={e}")

args_list = [1, 2]
kwargs_dict = {"d": 4, "e": 5}
complex_function(*args_list, 3, **kwargs_dict)  # a=1, b=2, c=3, d=4, e=5
```

---

## 5.4 返回值

### return 语句
`return` 语句用于从函数返回一个值，并结束函数的执行。

```python
# 简单返回值
def get_square(number):
    """返回数字的平方"""
    return number ** 2

result = get_square(5)
print(f"5的平方是: {result}")

# 返回多个值（实际上是返回一个元组）
def get_name_and_age():
    """返回姓名和年龄"""
    name = "Alice"
    age = 25
    return name, age  # 实际上是返回一个元组

# 接收返回值
person_info = get_name_and_age()
print(f"返回的元组: {person_info}")  # ('Alice', 25)
print(f"类型: {type(person_info)}")  # <class 'tuple'>

# 解包多个返回值
name, age = get_name_and_age()
print(f"姓名: {name}, 年龄: {age}")

# 返回字典（更清晰）
def get_person_info():
    """返回人员信息字典"""
    return {
        "name": "Bob",
        "age": 30,
        "city": "北京",
        "job": "工程师"
    }

info = get_person_info()
print(f"姓名: {info['name']}")
print(f"年龄: {info['age']}")
```

### 提前返回
函数中可以有多个 `return` 语句，但执行到第一个 `return` 就会结束函数。

```python
def check_number(number):
    """检查数字的奇偶性和正负"""
    if number == 0:
        return "零"  # 提前返回
    
    result = ""
    if number > 0:
        result += "正"
    else:
        result += "负"
    
    if number % 2 == 0:
        result += "偶数"
    else:
        result += "奇数"
    
    return result

# 测试
print(f"5: {check_number(5)}")    # 正奇数
print(f"-4: {check_number(-4)}")   # 负偶数
print(f"0: {check_number(0)}")     # 零

# 查找函数：找到就返回
def find_item(items, target):
    """在列表中查找目标项"""
    for index, item in enumerate(items):
        if item == target:
            return index  # 找到就立即返回
    
    return -1  # 没找到

fruits = ["apple", "banana", "orange", "grape"]
print(f"找到'orange'的位置: {find_item(fruits, 'orange')}")
print(f"找到'watermelon'的位置: {find_item(fruits, 'watermelon')}")
```

### 无返回值函数
没有 `return` 语句或 `return` 后面没有值的函数返回 `None`。

```python
def print_greeting(name):
    """打印问候语，不返回值"""
    print(f"你好，{name}！")

result = print_greeting("Alice")
print(f"函数的返回值: {result}")  # None
print(f"返回值类型: {type(result)}")  # <class 'NoneType'>

def return_none():
    """显式返回None"""
    return None

def implicit_none():
    """隐式返回None"""
    pass

print(f"显式返回: {return_none()}")
print(f"隐式返回: {implicit_none()}")
```

### 返回函数的函数
函数可以作为返回值。

```python
def get_multiplier(factor):
    """返回一个乘法函数"""
    def multiplier(x):
        return x * factor
    return multiplier

# 创建特定的乘法函数
double = get_multiplier(2)
triple = get_multiplier(3)

print(f"double(5) = {double(5)}")  # 10
print(f"triple(5) = {triple(5)}")  # 15

# 更复杂的例子
def create_calculator(operation):
    """根据操作创建计算器函数"""
    if operation == "add":
        def calculator(a, b):
            return a + b
    elif operation == "multiply":
        def calculator(a, b):
            return a * b
    elif operation == "power":
        def calculator(a, b):
            return a ** b
    else:
        def calculator(a, b):
            return None
    
    return calculator

# 使用
add_calc = create_calculator("add")
mult_calc = create_calculator("multiply")
pow_calc = create_calculator("power")

print(f"加法: {add_calc(3, 4)}")      # 7
print(f"乘法: {mult_calc(3, 4)}")     # 12
print(f"幂运算: {pow_calc(3, 4)}")    # 81
```

---

## 5.5 变量作用域

### 局部变量 vs 全局变量
```python
# 全局变量
global_var = "我是全局变量"

def test_scope():
    """测试变量作用域"""
    # 局部变量
    local_var = "我是局部变量"
    print(f"函数内访问局部变量: {local_var}")
    print(f"函数内访问全局变量: {global_var}")
    
    # 可以访问但不能直接修改全局变量（需要global声明）
    # global_var = "尝试修改"  # 这实际上创建了一个新的局部变量
    
test_scope()

print(f"函数外访问全局变量: {global_var}")
# print(f"函数外访问局部变量: {local_var}")  # 错误：NameError
```

### global 关键字
```python
counter = 0  # 全局变量

def increment():
    """增加计数器"""
    global counter  # 声明使用全局变量
    counter += 1
    print(f"计数器: {counter}")

increment()  # 计数器: 1
increment()  # 计数器: 2
increment()  # 计数器: 3

# 不使用global的情况
value = 10

def change_value():
    """尝试修改全局变量（但不使用global）"""
    value = 20  # 这创建了一个新的局部变量
    print(f"函数内的value: {value}")

change_value()  # 函数内的value: 20
print(f"函数外的value: {value}")  # 函数外的value: 10
```

### nonlocal 关键字
用于在嵌套函数中修改外层（非全局）作用域的变量。

```python
def outer_function():
    """外层函数"""
    outer_var = "外层变量"
    
    def inner_function():
        """内层函数"""
        nonlocal outer_var  # 声明使用外层变量
        outer_var = "被内层函数修改"
        print(f"内层函数: {outer_var}")
    
    print(f"调用前: {outer_var}")
    inner_function()
    print(f"调用后: {outer_var}")

outer_function()

# 多层嵌套
def level_one():
    """第一层"""
    x = 1
    
    def level_two():
        """第二层"""
        x = 2  # 这创建了一个新的level_two的局部变量
        
        def level_three():
            """第三层"""
            nonlocal x  # 修改level_two中的x
            x = 3
            print(f"level_three: x = {x}")
        
        level_three()
        print(f"level_two: x = {x}")
    
    level_two()
    print(f"level_one: x = {x}")

level_one()
```

### LEGB 规则
Python 查找变量的顺序：Local → Enclosing → Global → Built-in

```python
# L: Local（局部作用域）
def func_local():
    x = "local"
    print(f"Local: {x}")

# E: Enclosing（闭包函数外的函数）
def outer():
    x = "enclosing"
    
    def inner():
        print(f"Enclosing: {x}")  # 找到外层函数的x
    
    inner()

# G: Global（全局作用域）
x = "global"

def func_global():
    print(f"Global: {x}")  # 找到全局变量

# B: Built-in（内置作用域）
def func_builtin():
    print(f"Built-in: {len}")  # 找到内置函数len

# 测试
func_local()
outer()
func_global()
func_builtin()

# 名称冲突示例
x = "global x"

def test_legb():
    x = "enclosing x"
    
    def inner():
        x = "local x"
        print(f"Local wins: {x}")
    
    inner()
    print(f"After inner: {x}")

test_legb()
print(f"Global remains: {x}")
```

---

## 5.6 函数的高级特性

### 5.6.1 匿名函数（Lambda）
Lambda 函数是简洁的单行函数，适用于简单的操作。

```python
# 传统函数定义
def square(x):
    return x ** 2

# Lambda 等价写法
square_lambda = lambda x: x ** 2

print(f"传统函数: {square(5)}")          # 25
print(f"Lambda函数: {square_lambda(5)}") # 25

# Lambda 的典型应用：作为参数传递
numbers = [1, 2, 3, 4, 5]

# 使用传统函数
def is_even(x):
    return x % 2 == 0

even_numbers = list(filter(is_even, numbers))
print(f"偶数（传统）: {even_numbers}")

# 使用 Lambda
even_numbers_lambda = list(filter(lambda x: x % 2 == 0, numbers))
print(f"偶数（Lambda）: {even_numbers_lambda}")

# 排序时指定键
students = [
    ("Alice", 25),
    ("Bob", 20),
    ("Charlie", 22),
    ("David", 19)
]

# 按年龄排序
sorted_by_age = sorted(students, key=lambda s: s[1])
print(f"按年龄排序: {sorted_by_age}")

# 按姓名长度排序
sorted_by_name_length = sorted(students, key=lambda s: len(s[0]))
print(f"按姓名长度排序: {sorted_by_name_length}")

# 多个参数的 Lambda
add = lambda x, y: x + y
multiply = lambda x, y, z: x * y * z

print(f"加法: {add(3, 4)}")            # 7
print(f"乘法: {multiply(2, 3, 4)}")    # 24

# 立即调用的 Lambda
result = (lambda x, y: x ** 2 + y ** 2)(3, 4)
print(f"3² + 4² = {result}")  # 25
```

### 5.6.2 高阶函数
高阶函数是可以接受函数作为参数或返回函数的函数。

```python
# 接受函数作为参数
def apply_operation(numbers, operation):
    """对列表中的每个数应用操作"""
    results = []
    for num in numbers:
        results.append(operation(num))
    return results

# 定义一些操作函数
def double(x):
    return x * 2

def square(x):
    return x ** 2

def increment(x):
    return x + 1

# 使用高阶函数
numbers = [1, 2, 3, 4, 5]

doubled = apply_operation(numbers, double)
squared = apply_operation(numbers, square)
incremented = apply_operation(numbers, increment)

print(f"原列表: {numbers}")
print(f"加倍: {doubled}")
print(f"平方: {squared}")
print(f"加1: {incremented}")

# 使用Lambda简化
print(f"立方: {apply_operation(numbers, lambda x: x ** 3)}")

# 返回函数的函数
def create_greeter(greeting):
    """创建问候函数"""
    def greet(name):
        return f"{greeting}, {name}!"
    return greet

say_hello = create_greeter("Hello")
say_hi = create_greeter("Hi")
say_hola = create_greeter("Hola")

print(say_hello("Alice"))    # Hello, Alice!
print(say_hi("Bob"))         # Hi, Bob!
print(say_hola("Charlie"))   # Hola, Charlie!

# 内置高阶函数：map, filter, reduce
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# map: 对每个元素应用函数
squared = list(map(lambda x: x ** 2, numbers))
print(f"map - 平方: {squared}")

# filter: 过滤元素
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(f"filter - 偶数: {evens}")

# reduce: 累积计算
sum_all = reduce(lambda x, y: x + y, numbers)
product_all = reduce(lambda x, y: x * y, numbers)
print(f"reduce - 和: {sum_all}")
print(f"reduce - 积: {product_all}")
```

### 5.6.3 闭包
闭包是引用了自由变量的函数，这个自由变量将和函数一同存在。

```python
def outer_function(msg):
    """外层函数"""
    message = msg
    
    def inner_function():
        """内层函数（闭包）"""
        print(f"消息: {message}")
    
    return inner_function

# 创建闭包
hello_func = outer_function("Hello")
hi_func = outer_function("Hi")

hello_func()  # 消息: Hello
hi_func()     # 消息: Hi

# 闭包的实际应用：计数器
def make_counter():
    """创建计数器"""
    count = 0
    
    def counter():
        nonlocal count
        count += 1
        return count
    
    return counter

# 创建两个独立的计数器
counter1 = make_counter()
counter2 = make_counter()

print(f"计数器1: {counter1()}")  # 1
print(f"计数器1: {counter1()}")  # 2
print(f"计数器2: {counter2()}")  # 1
print(f"计数器1: {counter1()}")  # 3
print(f"计数器2: {counter2()}")  # 2

# 闭包的应用：函数工厂
def power_factory(exponent):
    """创建幂函数"""
    def power(base):
        return base ** exponent
    
    return power

# 创建特定的幂函数
square = power_factory(2)
cube = power_factory(3)
sqrt = power_factory(0.5)

print(f"平方: {square(5)}")  # 25
print(f"立方: {cube(5)}")    # 125
print(f"平方根: {sqrt(25)}") # 5.0
```

### 5.6.4 装饰器
装饰器是修改或增强函数功能的函数。

```python
# 简单装饰器
def simple_decorator(func):
    """简单装饰器：在函数调用前后打印消息"""
    def wrapper():
        print("函数调用前...")
        func()
        print("函数调用后...")
    
    return wrapper

@simple_decorator
def say_hello():
    print("Hello, World!")

say_hello()

# 装饰带参数的函数
def decorator_with_args(func):
    """处理带参数的函数"""
    def wrapper(*args, **kwargs):
        print(f"调用函数: {func.__name__}")
        print(f"参数: args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"结果: {result}")
        return result
    
    return wrapper

@decorator_with_args
def add(a, b):
    return a + b

@decorator_with_args
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

print(add(3, 4))
print(greet("Alice"))
print(greet("Bob", greeting="Hi"))

# 带参数的装饰器
def repeat(times):
    """重复执行函数指定次数"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            results = []
            for i in range(times):
                print(f"第 {i+1} 次执行:")
                result = func(*args, **kwargs)
                results.append(result)
            return results
        
        return wrapper
    return decorator

@repeat(3)
def say_hi(name):
    print(f"Hi, {name}!")
    return f"向{name}问好"

results = say_hi("Alice")
print(f"所有结果: {results}")

# 实际应用：计时装饰器
import time

def timer(func):
    """测量函数执行时间"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"函数 {func.__name__} 执行时间: {end_time - start_time:.6f}秒")
        return result
    
    return wrapper

@timer
def slow_function():
    """模拟耗时操作"""
    time.sleep(1)
    return "完成"

@timer
def fast_function():
    """快速函数"""
    return "快速完成"

print(slow_function())
print(fast_function())

# 多个装饰器（从下往上应用）
def decorator1(func):
    def wrapper():
        print("装饰器1 - 前")
        func()
        print("装饰器1 - 后")
    return wrapper

def decorator2(func):
    def wrapper():
        print("装饰器2 - 前")
        func()
        print("装饰器2 - 后")
    return wrapper

@decorator1
@decorator2
def original_function():
    print("原始函数")

print("\n多个装饰器:")
original_function()
# 输出:
# 装饰器1 - 前
# 装饰器2 - 前
# 原始函数
# 装饰器2 - 后
# 装饰器1 - 后
```

---

## 5.7 递归函数

递归函数是调用自身的函数，通常用于解决可以分解为相似子问题的问题。

### 基本递归
```python
# 阶乘：n! = n × (n-1) × ... × 1
def factorial_iterative(n):
    """迭代计算阶乘"""
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

def factorial_recursive(n):
    """递归计算阶乘"""
    # 基线条件（停止条件）
    if n == 0 or n == 1:
        return 1
    # 递归条件
    return n * factorial_recursive(n - 1)

# 测试
for n in range(1, 6):
    print(f"{n}! = {factorial_iterative(n)} (迭代)")
    print(f"{n}! = {factorial_recursive(n)} (递归)")

# 斐波那契数列：F(n) = F(n-1) + F(n-2), F(0)=0, F(1)=1
def fibonacci_iterative(n):
    """迭代计算斐波那契数"""
    if n == 0:
        return 0
    elif n == 1:
        return 1
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

def fibonacci_recursive(n):
    """递归计算斐波那契数"""
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# 测试（注意：递归版本效率很低）
for n in range(10):
    print(f"F({n}) = {fibonacci_iterative(n)} (迭代)")
    print(f"F({n}) = {fibonacci_recursive(n)} (递归)")
```

### 递归的注意事项
```python
# 1. 必须有基线条件（停止条件）
def infinite_recursion():
    """无限递归（不要运行！）"""
    infinite_recursion()  # 这将导致递归深度错误

# 2. 递归深度限制
import sys
print(f"Python默认递归深度限制: {sys.getrecursionlimit()}")

# 3. 使用缓存提高递归效率（记忆化）
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_cached(n):
    """使用缓存的斐波那契函数"""
    if n < 2:
        return n
    return fibonacci_cached(n - 1) + fibonacci_cached(n - 2)

# 测试性能
import time

def test_performance():
    """测试不同实现的性能"""
    n = 35
    
    # 递归（无缓存）
    start = time.time()
    result_recursive = fibonacci_recursive(n)
    time_recursive = time.time() - start
    
    # 递归（有缓存）
    start = time.time()
    result_cached = fibonacci_cached(n)
    time_cached = time.time() - start
    
    # 迭代
    start = time.time()
    result_iterative = fibonacci_iterative(n)
    time_iterative = time.time() - start
    
    print(f"计算 F({n}):")
    print(f"  递归（无缓存）: {time_recursive:.6f}秒")
    print(f"  递归（有缓存）: {time_cached:.6f}秒")
    print(f"  迭代: {time_iterative:.6f}秒")
    print(f"  结果: {result_recursive}")

# 只在小n值时测试，避免长时间运行
test_performance()
```

### 递归的实际应用
```python
# 1. 计算目录大小（递归遍历文件系统）
import os

def get_directory_size(path):
    """计算目录大小（递归）"""
    total_size = 0
    
    for entry in os.listdir(path):
        full_path = os.path.join(path, entry)
        
        if os.path.isfile(full_path):
            total_size += os.path.getsize(full_path)
        elif os.path.isdir(full_path):
            total_size += get_directory_size(full_path)  # 递归调用
    
    return total_size

# 注意：实际运行需要真实路径
# print(f"当前目录大小: {get_directory_size('.')} 字节")

# 2. 二分查找（递归版本）
def binary_search_recursive(arr, target, low=0, high=None):
    """递归二分查找"""
    if high is None:
        high = len(arr) - 1
    
    # 基线条件：查找范围为空
    if low > high:
        return -1
    
    mid = (low + high) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        # 在左半部分查找
        return binary_search_recursive(arr, target, low, mid - 1)
    else:
        # 在右半部分查找
        return binary_search_recursive(arr, target, mid + 1, high)

# 测试二分查找
sorted_numbers = [1, 3, 5, 7, 9, 11, 13, 15]
for target in [7, 1, 15, 8]:
    index = binary_search_recursive(sorted_numbers, target)
    if index != -1:
        print(f"找到 {target} 在索引 {index}")
    else:
        print(f"未找到 {target}")

# 3. 汉诺塔问题
def hanoi(n, source, target, auxiliary):
    """
    解决汉诺塔问题
    
    参数:
    n: 盘子数量
    source: 起始柱子
    target: 目标柱子
    auxiliary: 辅助柱子
    """
    if n == 1:
        print(f"移动盘子 1 从 {source} 到 {target}")
        return
    
    # 将n-1个盘子从source移动到auxiliary
    hanoi(n - 1, source, auxiliary, target)
    
    # 移动第n个盘子从source到target
    print(f"移动盘子 {n} 从 {source} 到 {target}")
    
    # 将n-1个盘子从auxiliary移动到target
    hanoi(n - 1, auxiliary, target, source)

print("\n汉诺塔问题 (3个盘子):")
hanoi(3, 'A', 'C', 'B')
```

---

## 5.8 内置函数介绍

Python 提供了许多内置函数，这里介绍一些常用的：

### 数学相关
```python
# abs(): 绝对值
print(f"abs(-10) = {abs(-10)}")
print(f"abs(3.14) = {abs(3.14)}")

# round(): 四舍五入
print(f"round(3.14159, 2) = {round(3.14159, 2)}")
print(f"round(3.5) = {round(3.5)}")
print(f"round(4.5) = {round(4.5)}")  # 注意：银行家舍入法

# pow(): 幂运算
print(f"pow(2, 3) = {pow(2, 3)}")      # 2³ = 8
print(f"pow(2, 3, 5) = {pow(2, 3, 5)}")  # 2³ mod 5 = 3

# divmod(): 返回商和余数
quotient, remainder = divmod(10, 3)
print(f"divmod(10, 3) = ({quotient}, {remainder})")  # (3, 1)
```

### 类型转换
```python
# int(), float(), str(), bool()
print(f"int('10') = {int('10')}")
print(f"float('3.14') = {float('3.14')}")
print(f"str(123) = '{str(123)}'")
print(f"bool(0) = {bool(0)}")
print(f"bool(1) = {bool(1)}")

# list(), tuple(), dict(), set()
print(f"list('abc') = {list('abc')}")
print(f"tuple([1, 2, 3]) = {tuple([1, 2, 3])}")
print(f"dict([('a', 1), ('b', 2)]) = {dict([('a', 1), ('b', 2)])}")
print(f"set([1, 2, 2, 3, 3]) = {set([1, 2, 2, 3, 3])}")
```

### 迭代和序列操作
```python
# len(): 长度
print(f"len('hello') = {len('hello')}")
print(f"len([1, 2, 3]) = {len([1, 2, 3])}")

# max(), min(): 最大值和最小值
numbers = [5, 2, 8, 1, 9]
print(f"max({numbers}) = {max(numbers)}")
print(f"min({numbers}) = {min(numbers)}")

# sum(): 求和
print(f"sum({numbers}) = {sum(numbers)}")

# sorted(): 排序（返回新列表）
print(f"sorted({numbers}) = {sorted(numbers)}")
print(f"sorted({numbers}, reverse=True) = {sorted(numbers, reverse=True)}")

# reversed(): 反转（返回迭代器）
print(f"list(reversed({numbers})) = {list(reversed(numbers))}")

# enumerate(): 枚举
fruits = ['apple', 'banana', 'orange']
print(f"list(enumerate(fruits)) = {list(enumerate(fruits))}")
print(f"list(enumerate(fruits, start=1)) = {list(enumerate(fruits, start=1))}")

# zip(): 合并多个序列
names = ['Alice', 'Bob', 'Charlie']
scores = [95, 88, 92]
print(f"list(zip(names, scores)) = {list(zip(names, scores))}")
```

### 输入输出
```python
# input(): 获取用户输入
# name = input("请输入你的名字: ")
# print(f"你好，{name}!")

# print(): 输出
print("Hello", "World", sep=", ")  # Hello, World
print("Hello", end=" ")  # 不换行
print("World")  # Hello World

# 格式化输出
name = "Alice"
age = 25
print(f"{name} is {age} years old")  # f-string (Python 3.6+)
print("{} is {} years old".format(name, age))  # format方法
print("%s is %d years old" % (name, age))  # %格式化
```

### 其他有用的内置函数
```python
# isinstance(): 类型检查
print(f"isinstance(10, int) = {isinstance(10, int)}")
print(f"isinstance('hello', (str, int)) = {isinstance('hello', (str, int))}")

# type(): 获取类型
print(f"type(10) = {type(10)}")
print(f"type('hello') = {type('hello')}")

# id(): 获取对象标识（内存地址）
x = 10
y = 10
print(f"id(x) = {id(x)}, id(y) = {id(y)}")  # 小整数可能相同

# help(): 获取帮助
# help(print)  # 查看print函数的帮助

# dir(): 查看对象的属性和方法
print(f"dir(list)[:5] = {dir(list)[:5]}")  # 只显示前5个

# range(): 生成数字序列
print(f"list(range(5)) = {list(range(5))}")
print(f"list(range(1, 6)) = {list(range(1, 6))}")
print(f"list(range(0, 10, 2)) = {list(range(0, 10, 2))}")
```

---

## 5.9 综合示例

### 示例1：计算器程序
```python
"""
多功能计算器程序
"""

def calculator():
    """计算器主函数"""
    operations = {
        "+": lambda x, y: x + y,
        "-": lambda x, y: x - y,
        "*": lambda x, y: x * y,
        "/": lambda x, y: x / y if y != 0 else "错误：除数不能为零",
        "%": lambda x, y: x % y if y != 0 else "错误：除数不能为零",
        "**": lambda x, y: x ** y
    }
    
    print("多功能计算器")
    print("=" * 40)
    print("支持的操作: +, -, *, /, %, **")
    print("输入 'q' 退出")
    print("=" * 40)
    
    while True:
        try:
            # 获取输入
            user_input = input("\n请输入表达式 (如: 5 + 3): ").strip()
            
            if user_input.lower() == 'q':
                print("感谢使用计算器！")
                break
            
            # 解析输入
            parts = user_input.split()
            if len(parts) != 3:
                print("错误：请输入 '数字 运算符 数字' 的格式")
                continue
            
            num1_str, op, num2_str = parts
            
            # 转换数字
            num1 = float(num1_str)
            num2 = float(num2_str)
            
            # 检查操作符
            if op not in operations:
                print(f"错误：不支持的操作符 '{op}'")
                print(f"支持的操作符: {', '.join(operations.keys())}")
                continue
            
            # 执行计算
            result = operations[op](num1, num2)
            
            # 输出结果
            print(f"{num1} {op} {num2} = {result}")
        
        except ValueError:
            print("错误：请输入有效的数字")
        except Exception as e:
            print(f"发生错误: {e}")

# 运行计算器
if __name__ == "__main__":
    calculator()
```

### 示例2：学生成绩管理系统（函数版）
```python
"""
学生成绩管理系统（使用函数进行模块化）
"""

# 数据存储
students = {}

def display_menu():
    """显示主菜单"""
    print("\n" + "=" * 50)
    print("学生成绩管理系统")
    print("=" * 50)
    print("1. 添加/修改学生成绩")
    print("2. 查看所有学生")
    print("3. 查看学生详情")
    print("4. 删除学生")
    print("5. 成绩统计")
    print("6. 保存数据")
    print("7. 加载数据")
    print("8. 退出系统")
    print("=" * 50)
    
    choice = input("请选择操作 (1-8): ").strip()
    return choice

def validate_score(score_str):
    """验证成绩输入"""
    try:
        score = float(score_str)
        if 0 <= score <= 100:
            return True, score
        else:
            return False, "成绩必须在0-100之间"
    except ValueError:
        return False, "请输入有效的数字"

def add_or_update_student():
    """添加或修改学生成绩"""
    name = input("请输入学生姓名: ").strip()
    
    if not name:
        print("姓名不能为空！")
        return
    
    print(f"\n为学生 {name} 输入成绩（输入空行结束）:")
    scores = []
    
    if name in students:
        print(f"该学生已有成绩: {students[name]}")
        choice = input("是否覆盖原有成绩？(y/n): ").lower()
        if choice != 'y':
            return
    
    count = 1
    while True:
        score_input = input(f"成绩 {count} (直接回车结束): ").strip()
        
        if not score_input:
            break
        
        valid, result = validate_score(score_input)
        if valid:
            scores.append(result)
            count += 1
        else:
            print(f"输入无效: {result}")
    
    if scores:
        students[name] = scores
        print(f"成功为 {name} 添加了 {len(scores)} 个成绩")
    else:
        print("未添加任何成绩")

def view_all_students():
    """查看所有学生"""
    if not students:
        print("还没有学生信息")
        return
    
    print(f"\n共有 {len(students)} 名学生:")
    print("-" * 60)
    print(f"{'姓名':<10} {'成绩数量':<10} {'平均分':<10} {'最高分':<10} {'最低分':<10}")
    print("-" * 60)
    
    for name, scores in students.items():
        if scores:
            avg = sum(scores) / len(scores)
            max_score = max(scores)
            min_score = min(scores)
            print(f"{name:<10} {len(scores):<10} {avg:<10.1f} {max_score:<10.1f} {min_score:<10.1f}")
        else:
            print(f"{name:<10} {'0':<10} {'N/A':<10} {'N/A':<10} {'N/A':<10}")
    
    print("-" * 60)

def view_student_detail():
    """查看学生详情"""
    name = input("请输入学生姓名: ").strip()
    
    if name not in students:
        print(f"找不到学生: {name}")
        return
    
    scores = students[name]
    print(f"\n学生: {name}")
    
    if scores:
        print(f"所有成绩: {scores}")
        print(f"成绩数量: {len(scores)}")
        print(f"平均分: {sum(scores) / len(scores):.1f}")
        print(f"最高分: {max(scores)}")
        print(f"最低分: {min(scores)}")
        
        # 成绩分布统计
        grade_levels = [
            ("优秀", 90, 100),
            ("良好", 80, 89),
            ("中等", 70, 79),
            ("及格", 60, 69),
            ("不及格", 0, 59)
        ]
        
        print("\n成绩分布:")
        for grade_name, low, high in grade_levels:
            if high == 100:
                count = len([s for s in scores if s >= low])
            else:
                count = len([s for s in scores if low <= s <= high])
            
            percentage = count / len(scores) * 100
            print(f"  {grade_name}: {count} 个 ({percentage:.1f}%)")
    else:
        print("该学生暂无成绩")

def delete_student():
    """删除学生"""
    name = input("请输入要删除的学生姓名: ").strip()
    
    if name not in students:
        print(f"找不到学生: {name}")
        return
    
    confirm = input(f"确定要删除 {name} 吗？(y/n): ").lower()
    if confirm == 'y':
        del students[name]
        print(f"已删除学生: {name}")
    else:
        print("取消删除")

def show_statistics():
    """显示统计信息"""
    if not students:
        print("还没有学生信息")
        return
    
    all_scores = []
    for scores in students.values():
        all_scores.extend(scores)
    
    if not all_scores:
        print("暂无成绩数据")
        return
    
    print("\n系统统计信息:")
    print("=" * 40)
    print(f"学生总数: {len(students)}")
    print(f"成绩总数: {len(all_scores)}")
    print(f"平均分（所有学生）: {sum(all_scores) / len(all_scores):.1f}")
    print(f"最高分: {max(all_scores)}")
    print(f"最低分: {min(all_scores)}")
    print(f"成绩范围: {min(all_scores)} - {max(all_scores)}")
    
    # 各分数段统计
    grade_ranges = [(90, 100), (80, 89), (70, 79), (60, 69), (0, 59)]
    grade_names = ["优秀", "良好", "中等", "及格", "不及格"]
    
    print("\n分数段分布:")
    total_count = len(all_scores)
    for (low, high), name in zip(grade_ranges, grade_names):
        if high == 100:
            count = len([s for s in all_scores if s >= low])
        else:
            count = len([s for s in all_scores if low <= s <= high])
        
        percentage = count / total_count * 100 if total_count > 0 else 0
        print(f"  {name} ({low}-{high}分): {count:4d} 个 ({percentage:6.1f}%)")
    
    # 绘制简单的条形图
    print("\n分数分布条形图:")
    max_bar_length = 50
    for (low, high), name in zip(grade_ranges, grade_names):
        if high == 100:
            count = len([s for s in all_scores if s >= low])
        else:
            count = len([s for s in all_scores if low <= s <= high])
        
        bar_length = int(count / total_count * max_bar_length) if total_count > 0 else 0
        bar = "█" * bar_length
        print(f"  {name:8s} {count:4d} |{bar}")

def save_data():
    """保存数据到文件"""
    import json
    
    try:
        with open("students.json", "w", encoding="utf-8") as f:
            json.dump(students, f, ensure_ascii=False, indent=2)
        print("数据已保存到 students.json")
    except Exception as e:
        print(f"保存数据时出错: {e}")

def load_data():
    """从文件加载数据"""
    import json
    import os
    
    if not os.path.exists("students.json"):
        print("数据文件不存在")
        return
    
    try:
        with open("students.json", "r", encoding="utf-8") as f:
            global students
            students = json.load(f)
        print(f"已加载 {len(students)} 名学生数据")
    except Exception as e:
        print(f"加载数据时出错: {e}")

def main():
    """主程序"""
    print("欢迎使用学生成绩管理系统！")
    
    while True:
        choice = display_menu()
        
        if choice == "1":
            add_or_update_student()
        elif choice == "2":
            view_all_students()
        elif choice == "3":
            view_student_detail()
        elif choice == "4":
            delete_student()
        elif choice == "5":
            show_statistics()
        elif choice == "6":
            save_data()
        elif choice == "7":
            load_data()
        elif choice == "8":
            confirm = input("确定要退出吗？(y/n): ").lower()
            if confirm == 'y':
                print("感谢使用，再见！")
                break
        else:
            print("无效选择，请重试")

# 运行系统
if __name__ == "__main__":
    main()
```

---

## 5.10 本章练习

### 练习1：基础函数练习
1. 编写一个函数，接受一个字符串，返回该字符串的反转形式
2. 编写一个函数，判断一个数是否为质数
3. 编写一个函数，接受一个列表，返回列表中的最大值和最小值（使用元组返回两个值）
4. 编写一个函数，计算圆的面积和周长（接受半径参数，返回面积和周长）

### 练习2：参数练习
1. 编写一个函数，接受任意数量的数字，返回它们的平均值
2. 编写一个函数，接受任意数量的关键字参数，将它们保存到字典并返回
3. 编写一个函数，使用默认参数创建个人信息（姓名、年龄、城市），允许部分覆盖
4. 编写一个函数，接受一个函数作为参数和一个列表，对列表中的每个元素应用该函数

### 练习3：递归练习
1. 使用递归计算 1+2+3+...+n 的和
2. 使用递归判断一个字符串是否是回文（正读反读都一样）
3. 使用递归实现二分查找算法
4. 使用递归生成杨辉三角的指定行

### 练习4：Lambda和装饰器练习
1. 使用 Lambda 表达式对列表 `[('Alice', 25), ('Bob', 20), ('Charlie', 30)]` 按年龄排序
2. 编写一个装饰器，记录函数的执行时间
3. 编写一个装饰器，缓存函数的计算结果（避免重复计算）
4. 编写一个带参数的装饰器，可以指定函数执行的重复次数

### 练习5：作用域练习
分析以下代码的输出，并解释原因：
```python
x = 10

def func1():
    x = 20
    print(f"func1: x = {x}")
    
    def inner():
        print(f"inner: x = {x}")
    
    inner()

def func2():
    global x
    x = 30
    print(f"func2: x = {x}")

print(f"全局: x = {x}")
func1()
print(f"全局: x = {x}")
func2()
print(f"全局: x = {x}")
```

### 练习6：综合项目
实现一个**简易银行账户系统**，要求：
1. 使用函数实现以下功能：
   - 创建账户（账户号、姓名、初始余额）
   - 存款
   - 取款（检查余额是否充足）
   - 查询余额
   - 查看交易记录
2. 使用字典存储账户信息
3. 使用装饰器记录所有交易（时间、类型、金额、余额）
4. 使用异常处理确保程序的健壮性（如无效输入、余额不足等）

### 练习7：代码调试
找出以下代码中的错误并修正：
```python
# 代码1：计算阶乘（有错误）
def factorial(n)
    if n == 0
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))

# 代码2：合并列表（有错误）
def merge_lists(list1, list2):
    result = []
    for i in range(len(list1)):
        result.append(list1[i] + list2[i])
    return result

list_a = [1, 2, 3]
list_b = [4, 5]
print(merge_lists(list_a, list_b))
```

---

## 总结

本章中，你学习了：
- ✅ **函数定义和调用**：使用 `def` 定义函数，通过函数名调用
- ✅ **函数参数**：位置参数、关键字参数、默认参数、可变参数 `*args` 和 `**kwargs`
- ✅ **返回值**：使用 `return` 返回结果，可以返回多个值
- ✅ **变量作用域**：局部变量、全局变量，`global` 和 `nonlocal` 关键字
- ✅ **函数的高级特性**：Lambda 表达式、高阶函数、闭包、装饰器
- ✅ **递归函数**：递归的原理和应用
- ✅ **内置函数**：Python 常用的内置函数

**关键要点**：
1. 函数是代码复用的基本单元，好的函数应该只做一件事
2. 合理使用参数可以提高函数的灵活性和可重用性
3. 理解作用域规则对于编写正确的函数至关重要
4. 装饰器是 Python 的强大特性，可以优雅地扩展函数功能
5. 递归可以简化代码，但要注意基线条件和性能问题

**编程建议**：
- 给函数和参数起有意义的名字
- 为复杂函数添加文档字符串
- 保持函数简短，一个函数只做一件事
- 优先使用返回值而不是修改全局变量
- 合理使用装饰器避免代码重复

---

## 扩展知识
- [Python 函数官方文档](https://docs.python.org/zh-cn/3/tutorial/controlflow.html#defining-functions)
- [Python 内置函数官方文档](https://docs.python.org/zh-cn/3/library/functions.html)
- [Python 装饰器指南](https://realpython.com/primer-on-python-decorators/)

---
**下一章**：[第6章：模块与包]

> 如果有任何问题，欢迎在 [Issues](https://github.com/SuperF2023/python-basics-tutorial/issues) 中提问！